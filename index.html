<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DI-TECH</title>
    
    <!-- ğŸ”¥ SheetJS ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€ (ì—‘ì…€ íŒŒì¼ ì½ê¸°ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Malgun Gothic', Arial, sans-serif; background: #f8f9fa; overflow: hidden; }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 8px 20px; display: flex;
            justify-content: space-between; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .header h1 { font-size: 16px; font-weight: bold; }
        .header-controls { display: flex; gap: 8px; }
        
        .btn {
            padding: 5px 10px; border: none; border-radius: 4px;
            cursor: pointer; font-size: 11px; font-weight: bold; transition: all 0.2s;
        }
        .btn-primary { background: #4CAF50; color: white; }
        .btn-secondary { background: white; color: #667eea; }
        .btn-danger { background: #f44336; color: white; font-size: 14px; padding: 2px 6px; }
        .btn-warning { background: #FF9800; color: white; }
        
        .main-layout { display: flex; height: calc(100vh - 40px); }
        .full-container { 
            flex: 1; 
            overflow: auto; 
            background: #fafafa; 
            padding: 0;
            position: relative;
        }
        .control-panel {
            background: white;
            padding: 10px 15px;
            border-radius: 0;
            margin-bottom: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: fixed;
            top: 35px;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            gap: 15px;
        }
        .control-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-right {
            width: 450px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .gantt-container-wrapper {
            margin-top: 80px;
            padding: 5px;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            background: white;
        }
        .control-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .model-list {
            max-height: 450px; overflow-y: auto; border: 1px solid #ddd;
            border-radius: 3px; margin-top: 3px; background: white;
            position: absolute;
            left: 15px;
            top: 155px;
            z-index: 200;
            width: 650px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .model-list-header {
            padding: 8px 10px;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            sticky: top;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .model-item {
            padding: 8px 10px; cursor: pointer; font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .model-item:hover { background: #e3f2fd; }
        
        .gantt-chart {
            background: white; border-radius: 4px; padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); min-width: fit-content;
        }
        
        .gantt-header {
            display: flex; background: #f5f5f5; border: 2px solid #333;
            margin-bottom: 1px; position: sticky; top: 0; z-index: 10;
        }
        
        .line-label {
            width: 40px; font-weight: bold; padding: 5px; text-align: center;
            background: #e3f2fd; border-right: 1px solid #333; font-size: 11px;
            display: flex; align-items: center; justify-content: center;
        }
        
        /* ğŸ”¥ ì„ì‹œ ë¼ì¸ ìŠ¤íƒ€ì¼ */
        .line-label.parking-line {
            background: #ffeb3b;
            color: #000;
            font-size: 10px;
        }
        
        .date-header { display: flex; flex: 1; }
        .date-col {
            display: flex; flex-direction: column; 
            min-width: 180px;
            border-left: 1px solid #333;
        }
        .date-day {
            padding: 4px; text-align: center; font-size: 10px;
            border-bottom: 1px solid #999; font-weight: bold;
        }
        .date-shifts { display: flex; }
        .shift-cell {
            flex: 1; padding: 2px; text-align: center;
            font-size: 10px; border-right: 1px solid #ddd; font-weight: bold;
        }
        .shift-cell:last-child { border-right: none; }
        
        .date-col.weekend .date-day { background: #ffe0e0; color: red; }
        .date-col.holiday .date-day { background: #ffcccc; color: red; }
        .date-col.special .date-day { background: #cce5ff; color: blue; }
        
        .gantt-row {
            display: flex; border: 1px solid #ddd;
            margin-bottom: 1px; 
            min-height: 103px;
            position: relative;
        }
        
        /* ğŸ”¥ ì„ì‹œ ë¼ì¸ í–‰ ìŠ¤íƒ€ì¼ */
        .gantt-row.parking-row {
            background: #fffbea;
            border: 2px solid #ffc107;
        }
        
        .gantt-line-area { display: flex; flex: 1; position: relative; }
        .gantt-slot {
            min-width: 90px;
            border-left: 1px solid #e0e0e0; position: relative;
        }
        .gantt-slot.weekend { background: #fff5f5; }
        .gantt-slot.holiday { background: #ffe8e8; }
        .gantt-slot.special { background: #e8f4ff; }
        
        .gantt-bar {
            position: absolute; 
            height: 100px;
            border-radius: 4px; 
            padding: 4px 6px;
            font-size: 10px; 
            color: #333; 
            font-weight: bold; 
            cursor: move;
            border: 2px solid rgba(0,0,0,0.2); 
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
            align-items: flex-start;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            z-index: 1; 
            top: 2px;
            overflow: hidden; 
            word-wrap: break-word; 
            text-align: left !important;
            transition: border 0.3s ease;
        }
        .gantt-bar > * {
            width: 100% !important;
            text-align: left !important;
            margin-left: 0 !important;
            padding-left: 0 !important;
        }
        .gantt-bar > div {
            width: 100%;
            text-align: left;
            white-space: normal;
            word-break: break-word;
            line-height: 1.3;
        }
        .gantt-bar:hover { box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 2; }
        .gantt-bar.dragging { opacity: 0.6; cursor: grabbing; }
        .gantt-bar.selected { 
            border: 3px solid #2196F3; 
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }
        .gantt-bar.pending-move {
            border: 3px solid #f44336 !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.6) !important;
            animation: pulse-red 1s infinite;
        }
        
        .gantt-bar.affected-move {
            border: 3px solid #FFC107 !important;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.6) !important;
            animation: pulse-yellow 1s infinite;
        }
        
        /* ğŸ”¥ ì„ì‹œ ë°” ìŠ¤íƒ€ì¼ */
        .gantt-bar.parked {
            opacity: 0.7;
            border: 2px dashed #999 !important;
        }
        
        /* ğŸ”¥ ST ì—†ìŒ ê²½ê³  ìŠ¤íƒ€ì¼ */
        .gantt-bar.no-st-warning {
            border: 3px solid #f44336 !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.6) !important;
        }
        
        .st-warning-badge {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #f44336;
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            z-index: 10;
        }
        
        /* ğŸ”¥ ì„ì‹œ ë±ƒì§€ */
        .parking-badge {
            position: absolute;
            top: 80px;
            left: 2px;
            background: #FF9800;
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            z-index: 10;
        }
        
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 15px rgba(244, 67, 54, 0.6); }
            50% { box-shadow: 0 0 25px rgba(244, 67, 54, 0.9); }
        }
        
        @keyframes pulse-yellow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 193, 7, 0.9); }
        }
        
        .color-1 { background: rgb(255, 235, 180); }
        .color-2 { background: rgb(255, 200, 220); }
        .color-3 { background: rgb(200, 230, 255); }
        .color-4 { background: rgb(220, 245, 200); }
        .color-5 { background: rgb(220, 220, 220); }
        .color-6 { 
            background: repeating-linear-gradient(
                45deg,
                #d0d0d0,
                #d0d0d0 8px,
                #a0a0a0 8px,
                #a0a0a0 10px
            );
        }
        
        .pcb-badge {
            display: inline-block; 
            padding: 1px 3px; 
            background: #ff9800;
            color: white; 
            border-radius: 2px; 
            font-size: 7px; 
            margin-left: 0;
            margin-right: 2px;
            vertical-align: baseline;
            font-weight: bold;
            font-family: 'Malgun Gothic', 'Arial', sans-serif;
        }
        .pcb-badge.pcb-1st {
            background: #4CAF50;
        }
        .pcb-badge.pcb-2nd {
            background: #ff9800;
        }
        .pcb-badge.pcb-both {
            background: #9C27B0;
        }
        .pcb-badge-small {
            display: inline-block; 
            padding: 1px 3px; 
            background: #ff9800;
            color: white; 
            border-radius: 2px; 
            font-size: 7px; 
            margin-left: 1px;
            margin-right: 1px;
            vertical-align: baseline;
            line-height: 1.3;
            font-weight: bold;
            font-family: 'Malgun Gothic', 'Arial', sans-serif;
        }
        .pcb-badge-small.pcb-1st {
            background: #4CAF50;
        }
        .pcb-badge-small.pcb-2nd {
            background: #ff9800;
        }
        .pcb-badge-small.pcb-both {
            background: #9C27B0;
        }
        
        #trashZone {
            transition: all 0.2s;
        }
        #trashZone:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .efficiency-badge {
            display: inline-block;
            background: #FF9800;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-left: 5px;
        }
        
        .move-confirm-panel {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 300;
            display: none;
            border: 3px solid #f44336;
        }
        
        .move-confirm-panel.show {
            display: block;
            animation: slideDown 0.3s ease;
        }
        
        /* ğŸ”¥ ST ì—†ìŒ ê²½ê³  ìŠ¤íƒ€ì¼ */
        .move-confirm-panel.st-warning {
            border: 3px solid #f44336;
        }
        
        /* ğŸ”¥ ì„ì‹œ ë¼ì¸ ì´ë™ ìŠ¤íƒ€ì¼ */
        .move-confirm-panel.parking-move {
            border: 3px solid #FFC107;
        }
        
        @keyframes slideDown {
            from { top: 60px; opacity: 0; }
            to { top: 100px; opacity: 1; }
        }
        
        .notice-area {
            display: flex;
            border: 3px solid #000;
            background: white;
            min-height: 60px;
            margin-top: 2px;
        }
        
        .notice-label {
            width: 40px;
            font-weight: bold;
            padding: 10px 5px;
            text-align: center;
            background: #fff3cd;
            border-right: 3px solid #000;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
        }
        
        .notice-content {
            flex: 1;
            padding: 8px 15px;
            color: red;
            font-size: 13px;
            font-weight: bold;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            display: flex;
            align-items: center;
        }
        
        /* ğŸ”¥ ë©”ëª¨ ìˆ¨ê¹€ ê¸°ëŠ¥ */
        .memo-hidden .gantt-bar-memo {
            display: none !important;
        }
        
        /* ğŸ”¥ ST ì—†ìŒ ê²½ê³  ìŠ¤íƒ€ì¼ */
        .st-warning-input {
            background: #ffe0e0 !important;
            border: 2px solid #f44336 !important;
        }
        
        /* ğŸ–¨ï¸ ì¸ì‡„ ì‹œ ìƒ‰ìƒ ìœ ì§€ */
        @media print {
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
            
            .gantt-bar {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .color-1, .color-2, .color-3, .color-4, .color-5, .color-6 {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .header {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .pcb-badge, .pcb-badge-small {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* ì¸ì‡„ ì‹œ ë¶ˆí•„ìš”í•œ ìš”ì†Œ ìˆ¨ê¸°ê¸° */
            .header-controls,
            .control-panel,
            #trashZone,
            .move-confirm-panel {
                display: none !important;
            }
            
            /* ê°„íŠ¸ì°¨íŠ¸ ì „ì²´ í‘œì‹œ */
            .gantt-container-wrapper {
                margin-top: 0 !important;
            }
            
            body {
                overflow: visible !important;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ­ DI-TECH SMD ìƒì‚°ê³„íš ì°¨íŠ¸</h1>
        <div class="header-controls">
            <input type="file" id="stFile" accept=".csv,.xlsx,.xls" style="display: none;">
            <button class="btn btn-secondary" onclick="document.getElementById('stFile').click()">ğŸ“‚ ST ì—…ë¡œë“œ (CSV/Excel)</button>
            <button class="btn btn-secondary" onclick="loadCSV()">ğŸ“‚ CSV ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <button class="btn btn-secondary" onclick="exportCSV()">ğŸ’¾ CSV ì €ì¥</button>
            <button class="btn btn-warning" onclick="cleanupPastWork()">ğŸ—‘ï¸ ê³¼ê±° ì‘ì—… ì •ë¦¬</button>
            <button class="btn btn-secondary" id="memoToggleBtn" onclick="toggleMemo()">ğŸ‘ï¸ ë©”ëª¨ ìˆ¨ê¹€</button>
            <input type="file" id="csvLoadFile" accept=".csv" style="display: none;">
        </div>
    </div>
    
    <div class="move-confirm-panel" id="moveConfirmPanel">
        <div style="text-align: center; margin-bottom: 10px;">
            <strong style="font-size: 14px; color: #f44336;">âš ï¸ ì´ë™ì„ í™•ì •í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</strong>
            <div id="moveInfo" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
        </div>
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn btn-primary" onclick="confirmMove()" style="padding: 8px 20px;">âœ“ í™•ì •</button>
            <button class="btn btn-secondary" onclick="cancelMove()" style="padding: 8px 20px;">âœ— ì·¨ì†Œ</button>
        </div>
    </div>
    
    <div class="main-layout">
        <div class="full-container">
            <div class="control-panel">
                <div class="control-left">
                    <div class="control-row">
                        <div class="control-section">
                            <label style="font-weight: bold; font-size: 11px; margin-right: 5px;">ì‹œì‘ë‚ ì§œ:</label>
                            <input type="date" id="startDate" style="padding: 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                            <label style="font-weight: bold; font-size: 11px; margin-left: 10px; margin-right: 5px;">íŠ¹ê·¼:</label>
                            <input type="text" id="specialWork" placeholder="ì˜ˆ: 10/25,10/26" style="padding: 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px; width: 150px;">
                            <label style="font-weight: bold; font-size: 11px; margin-left: 10px; margin-right: 5px;">íœ´ì¼:</label>
                            <input type="text" id="holidays" placeholder="ì˜ˆ: 10/28,10/29" style="padding: 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px; width: 150px;">
                        </div>
                        <div class="control-section">
                            <button class="btn btn-secondary" onclick="zoomOut()">â– ì¶•ì†Œ</button>
                            <button class="btn btn-secondary" onclick="zoomIn()">â• í™•ëŒ€</button>
                            <span style="font-size: 11px; margin-left: 10px;">ë°°ìœ¨: <strong id="zoomLevel">100</strong>%</span>
                            <button class="btn btn-primary" onclick="mergeSelected()" style="margin-left: 20px;">ğŸ”— ì„ íƒí•­ëª© ë¬¶ìŒ</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">âœ–ï¸ ì„ íƒí•´ì œ</button>
                            <div id="trashZone" style="display: inline-block; margin-left: 20px; padding: 6px 12px; background: #f44336; color: white; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">
                                ğŸ—‘ï¸ íœ´ì§€í†µ
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <input type="text" id="searchModel" placeholder="ğŸ” ëª¨ë¸ëª… ê²€ìƒ‰... (í•œê¸€/ì˜ë¬¸)" style="width: 180px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <input type="text" id="modelName" placeholder="ğŸ“¦ ëª¨ë¸ëª…/ê°€ì¹­" lang="en" style="width: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <select id="productionLine" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                            <option value="">ë¼ì¸</option>
                            <option value="A">A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                            <option value="D">D</option>
                            <option value="E">E</option>
                            <option value="F">F</option>
                            <option value="G">G</option>
                        </select>
                        <input type="number" id="quantity" placeholder="ìˆ˜ëŸ‰" lang="en" style="width: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <input type="number" id="duration" step="0.1" placeholder="ì†Œìš”ì¼" lang="en" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <input type="text" id="pcbType" placeholder="PCB" lang="en" style="width: 70px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <select id="color" style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                            <option value="1" style="background: rgb(255, 235, 180);">ğŸŸ¨ ë…¸ë‘</option>
                            <option value="2" style="background: rgb(255, 200, 220);">ğŸ©· í•‘í¬</option>
                            <option value="3" style="background: rgb(200, 230, 255);">ğŸŸ¦ íŒŒë‘</option>
                            <option value="4" style="background: rgb(220, 245, 200);">ğŸŸ© ì—°ë‘</option>
                            <option value="5" style="background: rgb(220, 220, 220);">â¬œ íšŒìƒ‰</option>
                            <option value="6">ğŸš« ë¯¸ê°€ë™</option>
                        </select>
                        <input type="text" id="memo" placeholder="ë©”ëª¨" style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                        <label style="display: flex; align-items: center; font-size: 11px; margin-left: 10px;">
                            <input type="checkbox" id="nightOff" style="margin-right: 5px;">
                            <span>ì£¼ê°„ì „ìš©</span>
                        </label>
                        <button class="btn btn-primary" onclick="addProduction()" style="margin-left: 10px;">â• ì¶”ê°€</button>
                    </div>
                </div>
                
                <div class="control-right" style="margin-left: -100px;">
                    <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 3px;">
                        <label style="font-weight: bold; font-size: 11px; flex: 1;">ğŸ“¢ ê³µì§€ì‚¬í•­</label>
                        <button class="btn btn-primary" onclick="updateNotice()" style="padding: 4px 10px; font-size: 11px;">ğŸ“ ì—…ë°ì´íŠ¸</button>
                    </div>
                    <textarea id="noticeText" placeholder="Gë¼ì¸ ë°‘ì— í‘œì‹œë  ê³µì§€ì‚¬í•­..." style="width: 100%; height: calc(100% - 40px); padding: 6px; border: 2px solid #FF9800; border-radius: 4px; font-size: 11px; resize: none; line-height: 1.4;"></textarea>
                </div>
                
                <div class="model-list" id="modelList" style="display: none;"></div>
            </div>
            
            <div class="gantt-container-wrapper">
                <div class="gantt-chart" id="ganttChart" style="transform-origin: top left;">
                    <div style="text-align: center; padding: 100px; color: #999;">
                        <h2>ê°„íŠ¸ì°¨íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</h2>
                        <p>ìƒì‚°ê³„íšì„ ì¶”ê°€í•˜ë©´ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let stData = [];
        let productionData = [];
        let zoomLevel = 100;
        let holidays = {};
        let selectedModelData = null;
        let currentBaseModelData = null;
        let draggedBar = null;
        let selectedBars = [];
        let globalEventsInitialized = false;
        let baseEfficiency = 0.65;
        let noticeContent = '';
        let originalCsvDate = null;
        
        let pendingMove = null;
        
        window.addEventListener('DOMContentLoaded', function() {
            document.getElementById('startDate').valueAsDate = new Date();
            
            const stFile = document.getElementById('stFile');
            const searchInput = document.getElementById('searchModel');
            const csvLoad = document.getElementById('csvLoadFile');
            const startDateInput = document.getElementById('startDate');
            const specialWorkInput = document.getElementById('specialWork');
            const holidaysInput = document.getElementById('holidays');
            
            if (stFile) {
                stFile.addEventListener('change', loadSTData);
            }
            if (searchInput) {
                searchInput.addEventListener('input', searchModel);
            }
            if (csvLoad) {
                csvLoad.addEventListener('change', importCSV);
            }
            
            if (startDateInput) {
                startDateInput.addEventListener('change', function() {
                    if (productionData.length > 0) {
                        generateGantt();
                    }
                });
            }
            
            if (specialWorkInput) {
                let specialWorkTimeout;
                specialWorkInput.addEventListener('input', function() {
                    clearTimeout(specialWorkTimeout);
                    specialWorkTimeout = setTimeout(function() {
                        if (productionData.length > 0) {
                            generateGantt();
                        }
                    }, 500);
                });
            }
            
            if (holidaysInput) {
                let holidayTimeout;
                holidaysInput.addEventListener('input', function() {
                    clearTimeout(holidayTimeout);
                    holidayTimeout = setTimeout(function() {
                        if (productionData.length > 0) {
                            generateGantt();
                        }
                    }, 500);
                });
            }
            
            const quantityInput = document.getElementById('quantity');
            const lineSelect = document.getElementById('productionLine');
            const pcbInput = document.getElementById('pcbType');
            const durationInput = document.getElementById('duration');
            
            if (quantityInput) {
                quantityInput.addEventListener('input', recalculateST);
            }
            if (lineSelect) {
                lineSelect.addEventListener('change', checkSTAvailability);
            }
            if (pcbInput) {
                pcbInput.addEventListener('input', recalculateST);
            }
            
            // ğŸ”¥ Delete í‚¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Delete' && selectedBars.length > 0) {
                    // ğŸ”¥ ì…ë ¥ì°½/textareaì— í¬ì»¤ìŠ¤ ìˆìœ¼ë©´ ì°¨íŠ¸ ì‚­ì œ ì•ˆ í•¨
                    const activeElement = document.activeElement;
                    if (activeElement && 
                        (activeElement.tagName === 'INPUT' || 
                         activeElement.tagName === 'TEXTAREA')) {
                        return; // ì…ë ¥ì°½ì—ì„œëŠ” í…ìŠ¤íŠ¸ë§Œ ì‚­ì œ
                    }
                    
                    deleteSelectedBars();
                }
            });
        });
        
        // ğŸ”¥ ì„ íƒëœ ë°” ì‚­ì œ í•¨ìˆ˜
        function deleteSelectedBars() {
            if (selectedBars.length === 0) return;
            
            const confirmMsg = selectedBars.length === 1 
                ? 'ì„ íƒí•œ ì‘ì—…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?' 
                : `ì„ íƒí•œ ${selectedBars.length}ê°œì˜ ì‘ì—…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
            
            if (!confirm(confirmMsg)) return;
            
            productionData = productionData.filter(p => !selectedBars.includes(p.id));
            selectedBars = [];
            generateGantt();
        }
        
        // ğŸ”¥ ì…ë ¥ì°½ ë“œë¡­ ì¡´ ì„¤ì • (ê°„íŠ¸ë°” â†’ ì…ë ¥ì°½ ë“œë˜ê·¸ ê¸°ëŠ¥)
        
        // ğŸ”¥ ê°„íŠ¸ë°” ì •ë³´ë¥¼ ì…ë ¥ì°½ì— ì±„ìš°ê¸° (Shift+í´ë¦­ìš©)
        function fillInputFromProduction(prod) {
            // ë¬¶ìŒëœ í•­ëª©ì€ ì²« ë²ˆì§¸ í•­ëª© ì •ë³´ ì‚¬ìš©
            let modelName = prod.model;
            let quantity = prod.quantity;
            let duration = prod.duration;
            let pcb = prod.pcb;
            
            if (prod.isMerged && prod.mergedData && prod.mergedData.length > 0) {
                const firstItem = prod.mergedData[0];
                modelName = firstItem.model;
                quantity = firstItem.quantity;
                duration = firstItem.duration;
                pcb = firstItem.pcb;
            }
            
            // ì„ì‹œ ë¼ì¸ì¸ ê²½ìš° originalDuration ì‚¬ìš©
            if (prod.line === 'ì„ì‹œ' && prod.originalDuration) {
                duration = prod.originalDuration;
            }
            
            document.getElementById('modelName').value = modelName;
            document.getElementById('quantity').value = quantity;
            document.getElementById('duration').value = duration;
            document.getElementById('pcbType').value = pcb || '';
            document.getElementById('color').value = prod.color;
            document.getElementById('memo').value = prod.memo || '';
            document.getElementById('nightOff').checked = prod.nightOff || false;
            
            // ë¼ì¸ì€ ë¹„ì›Œë‘  (ì‚¬ìš©ìê°€ ì„ íƒí•˜ë„ë¡)
            document.getElementById('productionLine').value = '';
            
            // ğŸ”¥ ST ë°ì´í„° ê²€ìƒ‰í•´ì„œ ì„¤ì • (ìë™ê³„ì‚°ìš©)
            currentBaseModelData = null;
            
            if (stData.length > 0) {
                // ëª¨ë¸ëª…ìœ¼ë¡œ ST ë°ì´í„° ì°¾ê¸°
                const modelNameNoSpace = modelName.replace(/\s/g, '').toLowerCase();
                
                const foundData = stData.find(item => {
                    const itemModelNoSpace = item.modelName.replace(/\s/g, '').toLowerCase();
                    const itemNicknameNoSpace = item.nickname.replace(/\s/g, '').toLowerCase();
                    
                    return itemModelNoSpace === modelNameNoSpace || 
                           itemNicknameNoSpace === modelNameNoSpace;
                });
                
                if (foundData) {
                    currentBaseModelData = {
                        modelName: foundData.modelName,
                        nickname: foundData.nickname
                    };
                } else {
                    // ST ë°ì´í„° ì—†ìœ¼ë©´ ëª¨ë¸ëª…ë§Œ ì„¤ì •
                    currentBaseModelData = {
                        modelName: modelName,
                        nickname: modelName
                    };
                }
            }
            
            // duration ì…ë ¥ë€ ì´ˆê¸°í™”
            const durationInput = document.getElementById('duration');
            durationInput.classList.remove('st-warning-input');
            durationInput.placeholder = 'ì†Œìš”ì¼';
            
            // ë¼ì¸ ì„ íƒë€ í¬ì»¤ìŠ¤
            document.getElementById('productionLine').focus();
        }
        
        // ğŸ”¥ ë³µì‚¬ ì™„ë£Œ í† ìŠ¤íŠ¸ ì•Œë¦¼
        function showCopyToast(modelName) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: #4CAF50;
                color: white;
                padding: 12px 24px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                animation: slideDown 0.3s ease;
            `;
            toast.textContent = 'ğŸ“‹ ' + modelName + ' ì •ë³´ ë³µì‚¬ë¨!';
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s ease';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 2000);
        }
        
        function updateNotice() {
            noticeContent = document.getElementById('noticeText').value;
            generateGantt();
        }
        
        // ğŸ”¥ ì…ë ¥ì°½ì—ì„œ ë¼ì¸ ë³€ê²½ ì‹œ ST ìœ ë¬´ í™•ì¸
        function checkSTAvailability() {
            if (!currentBaseModelData) {
                recalculateST();
                return;
            }
            
            const selectedLine = document.getElementById('productionLine').value;
            const inputQuantity = parseInt(document.getElementById('quantity').value) || 0;
            const currentPcb = document.getElementById('pcbType').value.trim();
            const durationInput = document.getElementById('duration');
            
            if (!selectedLine || inputQuantity === 0) {
                durationInput.style.background = '';
                durationInput.style.border = '';
                durationInput.placeholder = 'ì†Œìš”ì¼';
                return;
            }
            
            // PCB íƒ€ì… ë³€í™˜
            let pcbToFind = currentPcb;
            if (currentPcb === '1') {
                pcbToFind = '1ì°¨';
            } else if (currentPcb === '2') {
                pcbToFind = '2ì°¨';
            } else if (currentPcb === '12' || currentPcb === '1/2') {
                pcbToFind = '1/2ì°¨';
            }
            
            // ST ë°ì´í„° í™•ì¸
            let stExists = false;
            
            if (pcbToFind === '1/2ì°¨') {
                const lineModel1st = stData.find(item => 
                    item.modelName === currentBaseModelData.modelName && 
                    item.line === selectedLine &&
                    item.pcb === '1ì°¨'
                );
                const lineModel2nd = stData.find(item => 
                    item.modelName === currentBaseModelData.modelName && 
                    item.line === selectedLine &&
                    item.pcb === '2ì°¨'
                );
                stExists = lineModel1st || lineModel2nd;
            } else {
                const lineModel = stData.find(item => 
                    item.modelName === currentBaseModelData.modelName && 
                    item.line === selectedLine &&
                    item.pcb === pcbToFind
                );
                stExists = !!lineModel;
            }
            
            if (stExists) {
                // ST ìˆìŒ: ì •ìƒ ìŠ¤íƒ€ì¼ + ìë™ê³„ì‚°
                durationInput.classList.remove('st-warning-input');
                durationInput.placeholder = 'ì†Œìš”ì¼';
                recalculateST();
            } else {
                // ST ì—†ìŒ: ê²½ê³  ìŠ¤íƒ€ì¼ + ì´ˆê¸°í™”
                durationInput.classList.add('st-warning-input');
                durationInput.value = '';
                durationInput.placeholder = 'âš ï¸ STì—†ìŒ-ì§ì ‘ì…ë ¥';
            }
        }
        
        function recalculateST() {
            if (!currentBaseModelData) return;
            
            const selectedLine = document.getElementById('productionLine').value;
            const inputQuantity = parseInt(document.getElementById('quantity').value) || 0;
            const currentPcb = document.getElementById('pcbType').value.trim();
            const durationInput = document.getElementById('duration');
            
            if (!selectedLine || inputQuantity === 0) return;
            
            // PCB íƒ€ì… ë³€í™˜
            let pcbToFind = currentPcb;
            if (currentPcb === '1') {
                pcbToFind = '1ì°¨';
            } else if (currentPcb === '2') {
                pcbToFind = '2ì°¨';
            } else if (currentPcb === '12' || currentPcb === '1/2') {
                pcbToFind = '1/2ì°¨';
            }
            
            // ì–‘ë©´(1/2ì°¨)ì¸ ê²½ìš° 1ì°¨ + 2ì°¨ í•©ì‚°
            if (pcbToFind === '1/2ì°¨') {
                const lineModel1st = stData.find(item => 
                    item.modelName === currentBaseModelData.modelName && 
                    item.line === selectedLine &&
                    item.pcb === '1ì°¨'
                );
                
                const lineModel2nd = stData.find(item => 
                    item.modelName === currentBaseModelData.modelName && 
                    item.line === selectedLine &&
                    item.pcb === '2ì°¨'
                );
                
                let totalDuration = 0;
                let found = false;
                
                // 1ì°¨ ê³„ì‚°
                if (lineModel1st) {
                    let duration1st = 0;
                    
                    if (lineModel1st.quantity > 0) {
                        const ratio1st = inputQuantity / lineModel1st.quantity;
                        duration1st = lineModel1st.duration * ratio1st;
                    } else if (lineModel1st.stValue > 0 && lineModel1st.efficiency > 0) {
                        duration1st = inputQuantity / (60 / lineModel1st.stValue * 10 * lineModel1st.efficiency);
                    }
                    
                    if (duration1st > 0) {
                        totalDuration += duration1st;
                        found = true;
                    }
                }
                
                // 2ì°¨ ê³„ì‚°
                if (lineModel2nd) {
                    let duration2nd = 0;
                    
                    if (lineModel2nd.quantity > 0) {
                        const ratio2nd = inputQuantity / lineModel2nd.quantity;
                        duration2nd = lineModel2nd.duration * ratio2nd;
                    } else if (lineModel2nd.stValue > 0 && lineModel2nd.efficiency > 0) {
                        duration2nd = inputQuantity / (60 / lineModel2nd.stValue * 10 * lineModel2nd.efficiency);
                    }
                    
                    if (duration2nd > 0) {
                        totalDuration += duration2nd;
                        found = true;
                    }
                }
                
                if (found) {
                    durationInput.value = totalDuration.toFixed(1);
                    durationInput.classList.remove('st-warning-input');
                }
                return;
            }
            
            // ë‹¨ë©´(1ì°¨ ë˜ëŠ” 2ì°¨)ì¸ ê²½ìš°
            const lineModel = stData.find(item => 
                item.modelName === currentBaseModelData.modelName && 
                item.line === selectedLine &&
                item.pcb === pcbToFind
            );
            
            if (!lineModel) {
                return;
            }
            
            let calculatedDuration = 0;
            
            if (lineModel.quantity > 0) {
                const ratio = inputQuantity / lineModel.quantity;
                calculatedDuration = lineModel.duration * ratio;
            } 
            else if (lineModel.stValue > 0 && lineModel.efficiency > 0) {
                calculatedDuration = inputQuantity / (60 / lineModel.stValue * 10 * lineModel.efficiency);
            } 
            else {
                return;
            }
            
            durationInput.value = calculatedDuration.toFixed(1);
            durationInput.classList.remove('st-warning-input');
        }
        
        // ğŸ”¥ ìˆ˜ì • ëª¨ë‹¬ìš© ST ê³„ì‚° í•¨ìˆ˜
        function recalculateSTInModal(prodId) {
            const prod = productionData.find(p => p.id === prodId);
            if (!prod) return;
            
            const selectedLine = document.getElementById('edit_line').value;
            const inputQuantity = parseInt(document.getElementById('edit_qty').value) || 0;
            const currentPcb = document.getElementById('edit_pcb').value.trim();
            const durationInput = document.getElementById('edit_dur');
            
            // ğŸ”¥ ì„ì‹œ ë¼ì¸ì€ ìë™ê³„ì‚° ì•ˆ í•¨
            if (selectedLine === 'ì„ì‹œ') {
                durationInput.value = '1';
                durationInput.classList.remove('st-warning-input');
                durationInput.placeholder = 'ì†Œìš”ì¼';
                return;
            }
            
            if (!selectedLine || inputQuantity === 0) return;
            
            // PCB íƒ€ì… ë³€í™˜
            let pcbToFind = currentPcb;
            if (currentPcb === '1') {
                pcbToFind = '1ì°¨';
            } else if (currentPcb === '2') {
                pcbToFind = '2ì°¨';
            } else if (currentPcb === '12' || currentPcb === '1/2') {
                pcbToFind = '1/2ì°¨';
            }
            
            // ëª¨ë¸ëª…ìœ¼ë¡œ ST ì°¾ê¸°
            let baseModelName = prod.model;
            if (prod.isMerged && prod.mergedData && prod.mergedData.length > 0) {
                baseModelName = prod.mergedData[0].model;
            }
            
            // ì–‘ë©´(1/2ì°¨)ì¸ ê²½ìš°
            if (pcbToFind === '1/2ì°¨') {
                const lineModel1st = stData.find(item => 
                    (item.modelName === baseModelName || item.nickname === baseModelName) && 
                    item.line === selectedLine &&
                    item.pcb === '1ì°¨'
                );
                
                const lineModel2nd = stData.find(item => 
                    (item.modelName === baseModelName || item.nickname === baseModelName) && 
                    item.line === selectedLine &&
                    item.pcb === '2ì°¨'
                );
                
                let totalDuration = 0;
                let found = false;
                
                if (lineModel1st) {
                    let duration1st = 0;
                    if (lineModel1st.quantity > 0) {
                        const ratio1st = inputQuantity / lineModel1st.quantity;
                        duration1st = lineModel1st.duration * ratio1st;
                    } else if (lineModel1st.stValue > 0 && lineModel1st.efficiency > 0) {
                        duration1st = inputQuantity / (60 / lineModel1st.stValue * 10 * lineModel1st.efficiency);
                    }
                    if (duration1st > 0) {
                        totalDuration += duration1st;
                        found = true;
                    }
                }
                
                if (lineModel2nd) {
                    let duration2nd = 0;
                    if (lineModel2nd.quantity > 0) {
                        const ratio2nd = inputQuantity / lineModel2nd.quantity;
                        duration2nd = lineModel2nd.duration * ratio2nd;
                    } else if (lineModel2nd.stValue > 0 && lineModel2nd.efficiency > 0) {
                        duration2nd = inputQuantity / (60 / lineModel2nd.stValue * 10 * lineModel2nd.efficiency);
                    }
                    if (duration2nd > 0) {
                        totalDuration += duration2nd;
                        found = true;
                    }
                }
                
                if (found) {
                    durationInput.value = totalDuration.toFixed(1);
                    durationInput.classList.remove('st-warning-input');
                    durationInput.placeholder = 'ì†Œìš”ì¼';
                } else {
                    durationInput.classList.add('st-warning-input');
                    durationInput.placeholder = 'âš ï¸ STì—†ìŒ-ì§ì ‘ì…ë ¥';
                }
                return;
            }
            
            // ë‹¨ë©´ì¸ ê²½ìš°
            const lineModel = stData.find(item => 
                (item.modelName === baseModelName || item.nickname === baseModelName) && 
                item.line === selectedLine &&
                item.pcb === pcbToFind
            );
            
            if (!lineModel) {
                durationInput.classList.add('st-warning-input');
                durationInput.placeholder = 'âš ï¸ STì—†ìŒ-ì§ì ‘ì…ë ¥';
                return;
            }
            
            let calculatedDuration = 0;
            
            if (lineModel.quantity > 0) {
                const ratio = inputQuantity / lineModel.quantity;
                calculatedDuration = lineModel.duration * ratio;
            } 
            else if (lineModel.stValue > 0 && lineModel.efficiency > 0) {
                calculatedDuration = inputQuantity / (60 / lineModel.stValue * 10 * lineModel.efficiency);
            } 
            else {
                durationInput.classList.add('st-warning-input');
                durationInput.placeholder = 'âš ï¸ STì—†ìŒ-ì§ì ‘ì…ë ¥';
                return;
            }
            
            durationInput.value = calculatedDuration.toFixed(1);
            durationInput.classList.remove('st-warning-input');
            durationInput.placeholder = 'ì†Œìš”ì¼';
        }
        
        function loadSTData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                loadExcelSTData(file);
            } else if (fileName.endsWith('.csv')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    
                    if (text.includes(' ') || text.includes('\ufffd')) {
                        console.log('âš ï¸ UTF-8 ì¸ì½”ë”© ì‹¤íŒ¨, EUC-KR ì‹œë„...');
                        const reader2 = new FileReader();
                        reader2.onload = function(e2) {
                            parseSTCSV(e2.target.result);
                        };
                        reader2.readAsText(file, 'EUC-KR');
                    } else {
                        parseSTCSV(text);
                    }
                };
                reader.onerror = function() {
                    console.log('âš ï¸ UTF-8 ì½ê¸° ì‹¤íŒ¨, EUC-KRë¡œ ì¬ì‹œë„...');
                    const reader2 = new FileReader();
                    reader2.onload = function(e) {
                        parseSTCSV(e.target.result);
                    };
                    reader2.readAsText(file, 'EUC-KR');
                };
                reader.readAsText(file, 'UTF-8');
            } else {
                alert('âš ï¸ CSV ë˜ëŠ” Excel íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤!');
            }
        }
        
        function loadExcelSTData(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                        header: 1,
                        raw: false,
                        defval: ''
                    });
                    
                    console.log('âœ… ì—‘ì…€ ë°ì´í„° ì½ê¸° ì„±ê³µ:', jsonData.length + 'í–‰');
                    parseSTData(jsonData);
                    
                } catch (error) {
                    alert('âŒ ì—‘ì…€ íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: ' + error.message);
                    console.error(error);
                }
            };
            
            reader.onerror = function() {
                alert('âŒ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨!');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function parseSTData(rows) {
            try {
                stData = [];
                let skippedCount = 0;
                
                let baseEfficiency = 0.65;
                if (rows.length > 0) {
                    const headerRow = rows[0];
                    if (headerRow.length > 16 && headerRow[16]) {
                        const q1Value = parseFloat(headerRow[16]);
                        if (!isNaN(q1Value) && q1Value > 0) {
                            baseEfficiency = q1Value > 1 ? q1Value / 100 : q1Value;
                            console.log('í—¤ë”ì—ì„œ ê¸°ë³¸ íš¨ìœ¨(Q1):', (baseEfficiency * 100) + '%');
                        }
                    }
                }
                
                for (let i = 1; i < rows.length; i++) {
                    const cells = rows[i];
                    
                    if (!cells || cells.length < 10) {
                        skippedCount++;
                        continue;
                    }
                    
                    const modelName = (cells[0] || '').toString().trim();
                    if (!modelName) {
                        skippedCount++;
                        continue;
                    }
                    
                    let lineName = (cells[3] || '').toString().trim();
                    let pcbInfo = (cells[2] || '').toString().trim();
                    let pcbDisplay = '';
                    
                    if (pcbInfo.includes(' ')) {
                        const parts = pcbInfo.split(' ');
                        const pcbPart = parts[0];
                        const linePart = parts[1];
                        
                        if (pcbPart === '2') {
                            pcbDisplay = '2ì°¨';
                        } else if (pcbPart === '1') {
                            pcbDisplay = '1ì°¨';
                        }
                        
                        if (linePart && !lineName) {
                            lineName = linePart;
                        }
                    } else {
                        if (pcbInfo === '2' || pcbInfo.startsWith('2 ')) {
                            pcbDisplay = '2ì°¨';
                        } else if (pcbInfo === '1' || pcbInfo.startsWith('1 ')) {
                            pcbDisplay = '1ì°¨';
                        } else if (pcbInfo === '(1)') {
                            pcbDisplay = '1ì°¨';
                        } else if (pcbInfo === '(2)') {
                            pcbDisplay = '2ì°¨';
                        }
                    }
                    
                    const stValue = parseFloat(cells[5]) || 0;
                    const quantity = parseFloat(cells[9]) || 0;
                    
                    let efficiency = baseEfficiency;
                    if (cells[16] && cells[16].toString().trim() !== '') {
                        const modelEff = parseFloat(cells[16]);
                        if (!isNaN(modelEff) && modelEff > 0) {
                            efficiency = modelEff > 1 ? modelEff / 100 : modelEff;
                        }
                    }
                    
                    let duration = 0;
                    if (stValue > 0 && quantity > 0 && efficiency > 0) {
                        duration = quantity / (60 / stValue * 10 * efficiency);
                    }
                    
                    const nickname = (cells[17] || modelName).toString().trim() || modelName;
                    
                    stData.push({
                        modelName: modelName,
                        nickname: nickname,
                        line: lineName || '',
                        quantity: quantity,
                        duration: duration,
                        pcb: pcbDisplay,
                        stValue: stValue,
                        efficiency: efficiency
                    });
                }
                
                if (stData.length === 0) {
                    alert('âš ï¸ ST ë°ì´í„° 0ê°œ!');
                } else {
                    alert('âœ… ST ë°ì´í„° ' + stData.length + 'ê°œ ë¡œë“œ ì™„ë£Œ!\nê¸°ë³¸ íš¨ìœ¨: ' + (baseEfficiency * 100) + '%\nê±´ë„ˆë›´ ë°ì´í„°: ' + skippedCount + 'ê°œ');
                }
            } catch (error) {
                alert('âŒ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜: ' + error.message);
                console.error(error);
            }
        }
        
        function parseSTCSV(text) {
            const lines = text.split('\n');
            const rows = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const cells = parseCSVLine(line);
                rows.push(cells);
            }
            
            parseSTData(rows);
        }
        
        function parseCSVLine(line) {
            const cells = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                        current += '"';
                        i += 2;
                        continue;
                    } else {
                        inQuotes = !inQuotes;
                        i++;
                        continue;
                    }
                }
                
                if (char === ',' && !inQuotes) {
                    cells.push(current);
                    current = '';
                    i++;
                    continue;
                }
                
                current += char;
                i++;
            }
            
            cells.push(current);
            return cells;
        }
        
        function searchModel() {
            const searchText = document.getElementById('searchModel').value.trim();
            const modelList = document.getElementById('modelList');
            
            if (!searchText) {
                modelList.innerHTML = '';
                modelList.style.display = 'none';
                return;
            }
            
            if (stData.length === 0) {
                modelList.innerHTML = '<div class="model-item" style="color: #999; text-align: center; cursor: default;">ë¨¼ì € ST íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”</div>';
                modelList.style.display = 'block';
                return;
            }
            
            let pcbFilter = '';
            let cleanSearchText = searchText;
            
            const searchNoSpaceTmp = searchText.replace(/\s/g, '');
            if (/[12]$/.test(searchNoSpaceTmp)) {
                if (searchNoSpaceTmp.endsWith('1')) {
                    pcbFilter = '1ì°¨';
                    cleanSearchText = searchNoSpaceTmp.slice(0, -1);
                } else if (searchNoSpaceTmp.endsWith('2')) {
                    pcbFilter = '2ì°¨';
                    cleanSearchText = searchNoSpaceTmp.slice(0, -1);
                }
            }
            
            function generateAbbr(text) {
                return text.split(/\s+/)
                    .map(word => word.charAt(0))
                    .join('')
                    .toLowerCase();
            }
            
            const filtered = stData.filter(item => {
                const modelNameNoSpace = item.modelName.replace(/\s/g, '').toLowerCase();
                const nicknameNoSpace = item.nickname.replace(/\s/g, '').toLowerCase();
                const searchNoSpace = cleanSearchText.replace(/\s/g, '').toLowerCase();
                
                const modelAbbr = generateAbbr(item.modelName);
                const nicknameAbbr = generateAbbr(item.nickname);
                
                const modelMatches = modelNameNoSpace.includes(searchNoSpace) || 
                                   nicknameNoSpace.includes(searchNoSpace) ||
                                   modelAbbr.includes(searchNoSpace) ||
                                   nicknameAbbr.includes(searchNoSpace);
                
                if (pcbFilter) {
                    return modelMatches && item.pcb === pcbFilter;
                }
                
                return modelMatches;
            });
            
            const grouped = {};
            filtered.forEach(item => {
                if (!grouped[item.modelName]) {
                    grouped[item.modelName] = [];
                }
                grouped[item.modelName].push(item);
            });
            
            let html = '';
            const allLines = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
            
            Object.keys(grouped).sort().forEach(modelName => {
                const items = grouped[modelName].sort((a, b) => {
                    if (!a.line) return 1;
                    if (!b.line) return -1;
                    const lineCompare = a.line.localeCompare(b.line);
                    if (lineCompare !== 0) return lineCompare;
                    return (a.pcb || '').localeCompare(b.pcb || '');
                });
                
                const itemsWithLine = items.filter(item => item.line);
                
                if (itemsWithLine.length > 0) {
                    allLines.forEach(line => {
                        const lineItems = items.filter(item => item.line === line);
                        
                        lineItems.forEach((lineItem, idx) => {
                            const duration = parseFloat(lineItem.duration) || 0;
                            const durationText = duration > 0 ? duration.toFixed(1) + ' Shift' : 'ì •ë³´ì—†ìŒ';
                            const effText = lineItem.efficiency ? (lineItem.efficiency * 100).toFixed(0) + '%' : '';
                            const effBadge = effText && lineItem.efficiency !== baseEfficiency ? 
                                '<span class="efficiency-badge">' + effText + '</span>' : '';
                            
                            let pcbClass = 'pcb-badge';
                            if (lineItem.pcb === '1ì°¨') {
                                pcbClass += ' pcb-1st';
                            } else if (lineItem.pcb === '2ì°¨') {
                                pcbClass += ' pcb-2nd';
                            }
                            
                            const pcbDisplay = lineItem.pcb ? '<span class="' + pcbClass + '">' + lineItem.pcb + '</span>' : '';
                            
                            html += '<div class="model-item" onclick=\'selectModel(' + 
                                JSON.stringify(lineItem).replace(/'/g, "\\'") + ')\'>' +
                                modelName + '  ' + line + 'ë¼ì¸ ' + pcbDisplay + ' ' + durationText + effBadge + '</div>';
                        });
                    });
                } else {
                    const firstItem = items[0];
                    const duration = parseFloat(firstItem.duration) || 0;
                    const durationText = duration > 0 ? duration.toFixed(1) + ' Shift' : 'ì •ë³´ì—†ìŒ';
                    const effText = firstItem.efficiency ? (firstItem.efficiency * 100).toFixed(0) + '%' : '';
                    const effBadge = effText && firstItem.efficiency !== baseEfficiency ? 
                        '<span class="efficiency-badge">' + effText + '</span>' : '';
                    
                    html += '<div class="model-item" onclick=\'selectModel(' + 
                        JSON.stringify(firstItem).replace(/'/g, "\\'") + ')\'>' +
                        modelName + ' (ë¼ì¸ ì •ë³´ ì—†ìŒ) ' + durationText + effBadge + '</div>';
                }
            });
            
            if (Object.keys(grouped).length === 0) {
                html += '<div class="model-item" style="color: #999; text-align: center; cursor: default;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
            }
            
            modelList.innerHTML = html;
            modelList.style.display = 'block';
        }
        
        function selectModel(item) {
            selectedModelData = item;
            currentBaseModelData = item;
            document.getElementById('modelName').value = item.nickname || item.modelName;
            document.getElementById('productionLine').value = item.line;
            document.getElementById('quantity').value = item.quantity;
            document.getElementById('duration').value = item.duration.toFixed(1);
            document.getElementById('pcbType').value = item.pcb;
            document.getElementById('modelList').innerHTML = '';
            document.getElementById('modelList').style.display = 'none';
            document.getElementById('searchModel').value = '';
        }
        
        function addProduction() {
            const model = document.getElementById('modelName').value;
            const line = document.getElementById('productionLine').value;
            const qty = document.getElementById('quantity').value;
            const dur = document.getElementById('duration').value;
            const pcb = document.getElementById('pcbType').value;
            const color = document.getElementById('color').value;
            const memo = document.getElementById('memo').value;
            const nightOff = document.getElementById('nightOff').checked;
            
            let convertedPcb = pcb.trim();
            if (convertedPcb === '1') {
                convertedPcb = '1ì°¨';
            } else if (convertedPcb === '2') {
                convertedPcb = '2ì°¨';
            } else if (convertedPcb === '12' || convertedPcb === '1/2') {
                convertedPcb = '1/2ì°¨';
            }
            if (!model || !line || !qty || !dur) {
                alert('âš ï¸ í•„ìˆ˜ í•­ëª©ì„ ì…ë ¥í•˜ì„¸ìš”!');
                return;
            }
            
            const sameLineProds = productionData.filter(p => p.line === line);
            const maxOrder = sameLineProds.length > 0 
                ? Math.max(...sameLineProds.map(p => p.order)) 
                : -1;
            
            const production = {
                id: Date.now(),
                line: line,
                model: model,
                quantity: parseInt(qty),
                duration: parseFloat(dur),
                pcb: convertedPcb,
                color: color,
                memo: memo,
                nightOff: nightOff,
                order: maxOrder + 1
            };
            
            productionData.push(production);
            clearForm();
            generateGantt();
        }
        
        function clearForm() {
            document.getElementById('searchModel').value = '';
            document.getElementById('modelName').value = '';
            document.getElementById('productionLine').value = '';
            document.getElementById('quantity').value = '';
            const durationInput = document.getElementById('duration');
            durationInput.value = '';
            durationInput.classList.remove('st-warning-input');
            durationInput.placeholder = 'ì†Œìš”ì¼';
            document.getElementById('pcbType').value = '';
            document.getElementById('memo').value = '';
            document.getElementById('nightOff').checked = false;
            selectedModelData = null;
            currentBaseModelData = null;
        }
        
        function parseHolidays() {
            holidays = {};
            
            const startDateStr = document.getElementById('startDate').value;
            if (!startDateStr) return;
            const year = new Date(startDateStr).getFullYear();
            
            const specialWorkText = document.getElementById('specialWork').value;
            if (specialWorkText) {
                const dates = specialWorkText.split(',');
                dates.forEach(date => {
                    const trimmed = date.trim();
                    if (trimmed) {
                        const parts = trimmed.split('/');
                        if (parts.length === 2) {
                            const month = parts[0].padStart(2, '0');
                            const day = parts[1].padStart(2, '0');
                            const fullDate = year + '-' + month + '-' + day;
                            holidays[fullDate] = 'íŠ¹ê·¼';
                        }
                    }
                });
            }
            
            const holidayText = document.getElementById('holidays').value;
            if (holidayText) {
                const dates = holidayText.split(',');
                dates.forEach(date => {
                    const trimmed = date.trim();
                    if (trimmed) {
                        const parts = trimmed.split('/');
                        if (parts.length === 2) {
                            const month = parts[0].padStart(2, '0');
                            const day = parts[1].padStart(2, '0');
                            const fullDate = year + '-' + month + '-' + day;
                            holidays[fullDate] = 'íœ´ë¬´';
                        }
                    }
                });
            }
        }
        
        function generateGantt() {
            parseHolidays();
            
            const startDateStr = document.getElementById('startDate').value;
            if (!startDateStr) {
                alert('âš ï¸ ì‹œì‘ ë‚ ì§œë¥¼ ì…ë ¥í•˜ì„¸ìš”!');
                return;
            }
            
            const startDate = new Date(startDateStr);
            const days = 30;
            const lines = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; // ğŸ”¥ ì„ì‹œ ë¼ì¸ì€ ë³„ë„ ì²˜ë¦¬
            
            let html = '<div class="gantt-header"><div class="line-label">ë¼ì¸</div><div class="date-header">';
            
            for (let i = 0; i < days; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                const dayNames = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
                const dayName = dayNames[date.getDay()];
                const dateStr = date.toISOString().split('T')[0];
                
                let colClass = 'date-col';
                let isHoliday = false;
                
                if (holidays[dateStr] === 'íœ´ë¬´') {
                    colClass += ' holiday';
                    isHoliday = true;
                } else if (holidays[dateStr] === 'íŠ¹ê·¼') {
                    colClass += ' special';
                } else if (date.getDay() === 0 || date.getDay() === 6) {
                    colClass += ' weekend';
                    isHoliday = true;
                }
                
                html += '<div class="' + colClass + '">' +
                    '<div class="date-day">' + (date.getMonth()+1) + '/' + date.getDate() + ' (' + dayName + ')</div>' +
                    '<div class="date-shifts">' +
                    '<div class="shift-cell" style="' + (isHoliday ? 'color: red;' : '') + '">' + (isHoliday ? 'íœ´ë¬´' : 'ì£¼ê°„') + '</div>' +
                    '<div class="shift-cell" style="' + (isHoliday ? 'color: red;' : '') + '">' + (isHoliday ? 'íœ´ë¬´' : 'ì•¼ê°„') + '</div>' +
                    '</div></div>';
            }
            
            html += '</div></div>';
            
            // ğŸ”¥ ì¼ë°˜ ë¼ì¸ (A~G) ìƒì„±
            lines.forEach(line => {
                const lineProds = productionData.filter(p => p.line === line).sort((a, b) => a.order - b.order);
                
                html += '<div class="gantt-row">' +
                    '<div class="line-label">ë¼ì¸ ' + line + '</div>' +
                    '<div class="gantt-line-area" data-line="' + line + '">';
                
                let slotIndex = 0;
                for (let i = 0; i < days; i++) {
                    const date = new Date(startDate);
                    date.setDate(date.getDate() + i);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    let isHoliday = false;
                    let cellClass = 'gantt-slot';
                    
                    if (holidays[dateStr] === 'íœ´ë¬´' || date.getDay() === 0 || date.getDay() === 6) {
                        isHoliday = true;
                        cellClass += ' holiday';
                    }
                    
                    if (holidays[dateStr] === 'íŠ¹ê·¼') cellClass += ' special';
                    
                    html += '<div class="' + cellClass + '" data-slot="' + slotIndex + '"></div>';
                    slotIndex++;
                    html += '<div class="' + cellClass + '" data-slot="' + slotIndex + '"></div>';
                    slotIndex++;
                }
                
                html += renderBarsForLine(lineProds, line, startDate, days);
                html += '</div></div>';
            });
            
            // ğŸ”¥ ê³µì§€ì‚¬í•­
            html += '<div class="notice-area">' +
                '<div class="notice-label">ê³µì§€</div>' +
                '<div class="notice-content">' + (noticeContent || 'ê³µì§€ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤.') + '</div>' +
                '</div>';
            
            // ğŸ”¥ ì„ì‹œ ë¼ì¸ ìƒì„±
            const parkingProds = productionData.filter(p => p.line === 'ì„ì‹œ').sort((a, b) => a.order - b.order);
            
            html += '<div class="gantt-row parking-row">' +
                '<div class="line-label parking-line">ì„ì‹œ</div>' +
                '<div class="gantt-line-area" data-line="ì„ì‹œ">';
            
            let parkingSlotIndex = 0;
            for (let i = 0; i < days; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                const dateStr = date.toISOString().split('T')[0];
                
                let cellClass = 'gantt-slot';
                
                html += '<div class="' + cellClass + '" data-slot="' + parkingSlotIndex + '"></div>';
                parkingSlotIndex++;
                html += '<div class="' + cellClass + '" data-slot="' + parkingSlotIndex + '"></div>';
                parkingSlotIndex++;
            }
            
            html += renderBarsForLine(parkingProds, 'ì„ì‹œ', startDate, days, true);
            html += '</div></div>';
            
            document.getElementById('ganttChart').innerHTML = html;
            console.log('ê°„íŠ¸ì°¨íŠ¸ ìƒì„± ì™„ë£Œ');
            
            setTimeout(function() {
                const testBars = document.querySelectorAll('.gantt-bar');
                console.log('ìƒì„±ëœ ê°„íŠ¸ë°” ê°œìˆ˜:', testBars.length);
                enableBarDrag();
            }, 100);
        }
        
        // ğŸ”¥ ë¼ì¸ë³„ ë°” ë Œë”ë§ í•¨ìˆ˜
        function renderBarsForLine(lineProds, line, startDate, days, isParking = false) {
            let html = '';
            let currentSlot = 0;
            
            lineProds.forEach(prod => {
                const skipNight = prod.nightOff;
                let slotsNeeded = Math.ceil(prod.duration);
                let scheduledSlots = 0;
                let checkSlot = currentSlot;
                let blockStart = -1;
                let blocks = [];
                
                // ğŸ”¥ ì„ì‹œ ë¼ì¸ì€ ë¬´ì¡°ê±´ 1 SHIFT
                if (isParking) {
                    blocks.push({start: 0, end: 0});
                } else {
                    while (scheduledSlots < slotsNeeded && checkSlot < days * 2) {
                        const slotDateIndex = Math.floor(checkSlot / 2);
                        const slotShiftIndex = checkSlot % 2;
                        
                        if (slotDateIndex >= days) break;
                        
                        const checkDate = new Date(startDate);
                        checkDate.setDate(checkDate.getDate() + slotDateIndex);
                        const checkDateStr = checkDate.toISOString().split('T')[0];
                        
                        const isHoliday = holidays[checkDateStr] === 'íœ´ë¬´' ||
                                        ((checkDate.getDay() === 0 || checkDate.getDay() === 6) &&
                                        holidays[checkDateStr] !== 'íŠ¹ê·¼');
                        
                        if (isHoliday) {
                            if (blockStart >= 0) {
                                blocks.push({start: blockStart, end: checkSlot - 1});
                                blockStart = -1;
                            }
                            checkSlot++;
                            continue;
                        }
                        
                        if (skipNight && slotShiftIndex === 1) {
                            if (blockStart >= 0) {
                                blocks.push({start: blockStart, end: checkSlot - 1});
                                blockStart = -1;
                            }
                            checkSlot++;
                            continue;
                        }
                        
                        if (blockStart === -1) blockStart = checkSlot;
                        scheduledSlots++;
                        checkSlot++;
                    }
                    
                    if (blockStart >= 0) {
                        blocks.push({start: blockStart, end: checkSlot - 1});
                    }
                }
                
                blocks.forEach(block => {
                    const slotWidth = 90;
                    const width = isParking ? slotWidth : ((block.end - block.start + 1) * slotWidth);
                    const left = isParking ? (currentSlot * slotWidth) : (block.start * slotWidth);
                    
                    let pendingClass = '';
                    let stWarningBadge = '';
                    let parkingBadge = '';
                    
                    // ğŸ”¥ ì„ì‹œ ë°” ìŠ¤íƒ€ì¼
                    if (isParking) {
                        pendingClass += ' parked';
                        if (prod.originalDuration) {
                            parkingBadge = '<div class="parking-badge">ì›ë˜: ' + prod.originalDuration.toFixed(1) + 'S</div>';
                        }
                    }
                    
                    if (pendingMove) {
                        if (pendingMove.barId === prod.id) {
                            pendingClass += ' pending-move';
                            if (pendingMove.noST) {
                                pendingClass += ' no-st-warning';
                                stWarningBadge = '<div class="st-warning-badge">âš ï¸ STì—†ìŒ</div>';
                            }
                        } else if (pendingMove.affectedIds && pendingMove.affectedIds.includes(prod.id)) {
                            pendingClass += ' affected-move';
                        }
                    }
                    
                    html += '<div class="gantt-bar color-' + prod.color + pendingClass + '" ' +
                        'style="width: ' + width + 'px; left: ' + left + 'px;" ' +
                        'draggable="true" data-id="' + prod.id + '" data-line="' + line + '" ' +
                        'data-start-slot="' + block.start + '" data-order="' + prod.order + '">' +
                        stWarningBadge + parkingBadge;
                    
                    const modelText = prod.model;
                    let fontSize = 10;
                    const charCount = modelText.length;
                    
                    if (charCount > 150) {
                        fontSize = 9;
                    } else if (charCount > 120) {
                        fontSize = 9.5;
                    }
                    
                    if (prod.isMerged) {
                        let displayHtml = modelText;
                        
                        displayHtml = displayHtml.replace(/1\s*\/\s*2\s*ì°¨/g, '<span class="pcb-badge-small pcb-both">ì–‘ë©´</span>');
                        
                        displayHtml = displayHtml.replace(/(\dì°¨)/g, function(match) {
                            let pcbClass = 'pcb-badge-small';
                            if (match === '1ì°¨') {
                                pcbClass += ' pcb-1st';
                            } else if (match === '2ì°¨') {
                                pcbClass += ' pcb-2nd';
                            }
                            return '<span class="' + pcbClass + '">' + match + '</span>';
                        });
                        
                        html += '<div style="width: 100%; font-size: ' + fontSize + 'px; font-weight: bold; text-align: left !important; display: block; line-height: 1.3; word-wrap: break-word; overflow-wrap: break-word; max-height: ' + (prod.memo ? '60px' : '75px') + '; overflow: hidden;">' + displayHtml + '</div>';
                        
                        if (prod.memo) {
                            html += '<div class="gantt-bar-memo" style="width: 100%; font-size: 9px; color: red; text-align: left !important; display: block; margin-top: 2px;">ğŸ”– ' + prod.memo + '</div>';
                        }
                        
                        html += '<div style="width: 100%; font-size: 10px; color: #666; text-align: left !important; display: block; margin-top: 2px; position: absolute; bottom: 3px;">' + parseFloat(prod.duration).toFixed(1) + ' Shift</div>';
                    } else {
                        let modelDisplay = prod.model;
                        if (prod.pcb && !prod.model.includes(prod.pcb)) {
                            modelDisplay += ' ';
                            
                            let pcbClass = 'pcb-badge';
                            let pcbText = prod.pcb;
                            
                            if (prod.pcb === '1ì°¨') {
                                pcbClass += ' pcb-1st';
                            } 
                            else if (prod.pcb === '2ì°¨') {
                                pcbClass += ' pcb-2nd';
                            }
                            else if (prod.pcb.includes('1') && prod.pcb.includes('2')) {
                                pcbClass += ' pcb-both';
                                pcbText = 'ì–‘ë©´';
                            }
                            else {
                                pcbClass += ' pcb-2nd';
                            }
                            
                            html += '<div style="width: 100%; font-size: ' + fontSize + 'px; font-weight: bold; text-align: left !important; display: block; line-height: 1.3; word-wrap: break-word;">' +
                                modelDisplay.trim() + ' <span class="' + pcbClass + '" style="display: inline-block; vertical-align: middle;">' + pcbText + '</span></div>';
                        } else {
                            html += '<div style="width: 100%; font-size: ' + fontSize + 'px; font-weight: bold; text-align: left !important; display: block; line-height: 1.3; word-wrap: break-word;">' + modelDisplay + '</div>';
                        }
                        
                        const quantityText = prod.quantityDisplay || (prod.quantity.toLocaleString() + 'ea');
                        html += '<div style="width: 100%; font-size: 10px; margin-bottom: 2px; text-align: left !important; display: block;">' + quantityText + '</div>';
                        
                        if (prod.memo) {
                            html += '<div class="gantt-bar-memo" style="width: 100%; font-size: 9px; color: red; margin-bottom: 2px; text-align: left !important; display: block;">ğŸ”– ' + prod.memo + '</div>';
                        }
                        
                        let efficiencyText = '';
                        if (prod.pcb && prod.pcb.includes('ì°¨')) {
                            let stItem = null;
                            
                            const isBothSide = prod.pcb.includes('1') && prod.pcb.includes('2');
                            
                            if (isBothSide) {
                                stItem = stData.find(item => 
                                    item.modelName === prod.model || item.nickname === prod.model
                                );
                            } else {
                                stItem = stData.find(item => 
                                    (item.modelName === prod.model || item.nickname === prod.model) && 
                                    item.pcb === prod.pcb &&
                                    item.line === prod.line
                                );
                                
                                if (!stItem) {
                                    stItem = stData.find(item => 
                                        (item.modelName === prod.model || item.nickname === prod.model) && 
                                        item.pcb === prod.pcb &&
                                        !item.line
                                    );
                                }
                                
                                if (!stItem) {
                                    stItem = stData.find(item => 
                                        (item.modelName === prod.model || item.nickname === prod.model) && 
                                        item.pcb === prod.pcb
                                    );
                                }
                            }
                            
                            if (stItem && stItem.efficiency) {
                                const effPercent = (stItem.efficiency * 100).toFixed(0);
                                efficiencyText = ' / ' + effPercent + '%';
                            }
                        }
                        
                        html += '<div style="width: 100%; font-size: 9px; color: #666; text-align: left !important; display: block;">' + parseFloat(prod.duration).toFixed(1) + ' Shift' + efficiencyText + '</div>';
                    }
                    
                    html += '</div>';
                });
                
                currentSlot = isParking ? currentSlot + 1 : checkSlot;
            });
            
            return html;
        }
        
        function enableBarDrag() {
            const bars = document.querySelectorAll('.gantt-bar');
            
            if (bars.length === 0) {
                console.warn('ê²½ê³ : ê°„íŠ¸ë°”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            console.log('ê°„íŠ¸ë°” ì´ë²¤íŠ¸ ë°”ì¸ë”©:', bars.length + 'ê°œ');
            
            bars.forEach(bar => {
                let clickTimer = null;
                
                bar.addEventListener('click', function(e) {
                    e.stopPropagation();
                    
                    // ğŸ”¥ Shift + í´ë¦­ = ì…ë ¥ì°½ì— ë³µì‚¬
                    if (e.shiftKey) {
                        const barId = parseInt(this.dataset.id);
                        const prod = productionData.find(p => p.id === barId);
                        
                        if (prod) {
                            fillInputFromProduction(prod);
                            showCopyToast(prod.model);
                            
                            // ì‹œê°ì  í”¼ë“œë°± - ë…¹ìƒ‰ í•˜ì´ë¼ì´íŠ¸
                            this.style.boxShadow = '0 0 15px 3px #4CAF50';
                            setTimeout(() => {
                                this.style.boxShadow = '';
                            }, 500);
                        }
                        return;
                    }
                    
                    if (clickTimer !== null) {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                        const barId = parseInt(this.dataset.id);
                        editProduction(barId);
                        return;
                    }
                    
                    clickTimer = setTimeout(() => {
                        clickTimer = null;
                        const barId = parseInt(this.dataset.id);
                        
                        if (this.classList.contains('selected')) {
                            this.classList.remove('selected');
                            selectedBars = selectedBars.filter(id => id !== barId);
                        } else {
                            this.classList.add('selected');
                            if (!selectedBars.includes(barId)) {
                                selectedBars.push(barId);
                            }
                        }
                    }, 250);
                });
                
                bar.addEventListener('dragstart', function(e) {
                    draggedBar = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                bar.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedBar = null;
                });
            });
            
            const trashZone = document.getElementById('trashZone');
            if (trashZone && !globalEventsInitialized) {
                trashZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    this.style.background = '#d32f2f';
                    this.style.transform = 'scale(1.1)';
                });
                
                trashZone.addEventListener('dragleave', function() {
                    this.style.background = '#f44336';
                    this.style.transform = 'scale(1)';
                });
                
                trashZone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.background = '#f44336';
                    this.style.transform = 'scale(1)';
                    
                    if (!draggedBar) return;
                    
                    const barId = parseInt(draggedBar.dataset.id);
                    productionData = productionData.filter(p => p.id !== barId);
                    generateGantt();
                });
                
                globalEventsInitialized = true;
            }
            
            const lineAreas = document.querySelectorAll('.gantt-line-area');
            lineAreas.forEach(area => {
                area.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                area.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (!draggedBar) return;
                    
                    const targetLine = this.dataset.line;
                    const barId = parseInt(draggedBar.dataset.id);
                    const prod = productionData.find(p => p.id === barId);
                    
                    if (!prod) return;
                    
                    const oldLine = prod.line;
                    
                    const backup = productionData.map(p => ({
                        id: p.id,
                        line: p.line,
                        order: p.order,
                        duration: p.duration,
                        originalDuration: p.originalDuration
                    }));
                    
                    // ğŸ”¥ ë¼ì¸ ê°„ ì´ë™
                    if (oldLine !== targetLine) {
                        const targetLineProds = productionData.filter(p => p.line === targetLine && p.id !== barId);
                        const newOrder = targetLineProds.length; // ğŸ”¥ ë§¨ ë’¤ì— ì¶”ê°€
                        
                        prod.line = targetLine;
                        prod.order = newOrder;
                        
                        // ğŸ”¥ ì„ì‹œ ë¼ì¸ ì²˜ë¦¬
                        if (targetLine === 'ì„ì‹œ') {
                            // ì¼ë°˜ ë¼ì¸ â†’ ì„ì‹œ ë¼ì¸
                            if (!prod.originalDuration) {
                                prod.originalDuration = prod.duration;
                            }
                            prod.duration = 1;
                            
                        pendingMove = {
                            barId: barId,
                            backup: backup,
                            affectedIds: [],
                            isParking: true
                        };
                    } else if (oldLine === 'ì„ì‹œ') {
                        // ì„ì‹œ ë¼ì¸ â†’ ì¼ë°˜ ë¼ì¸
                        const recalcResult = recalculateDurationOnDrag(prod, targetLine);
                        
                        // ST ì¬ê³„ì‚° ì‹¤íŒ¨ ì‹œ originalDuration ë³µì›
                        if (!recalcResult.found && prod.originalDuration) {
                            prod.duration = prod.originalDuration;
                        }
                        
                        // originalDuration ì œê±°
                        delete prod.originalDuration;
                        
                        pendingMove = {
                            barId: barId,
                            backup: backup,
                            affectedIds: [],
                            noST: !recalcResult.found,
                            isUnparking: true
                        };
                    } else {
                        // ì¼ë°˜ ë¼ì¸ â†’ ì¼ë°˜ ë¼ì¸
                        const recalcResult = recalculateDurationOnDrag(prod, targetLine);
                        
                        pendingMove = {
                            barId: barId,
                            backup: backup,
                            affectedIds: [],
                            noST: !recalcResult.found
                        };
                    }
                    
                } 
                // ğŸ”¥ ê°™ì€ ë¼ì¸ ë‚´ ìˆœì„œ ë³€ê²½
                else {
                    const dropX = e.clientX - this.getBoundingClientRect().left;
                    const slotWidth = 90;
                    const targetSlot = Math.floor(dropX / slotWidth);
                    
                    const sameLineProds = productionData
                        .filter(p => p.line === targetLine && p.id !== barId)
                        .sort((a, b) => a.order - b.order);
                    
                    let newOrder = 0;
                    let inserted = false;
                    const affectedIds = [];
                    
                    sameLineProds.forEach((p, idx) => {
                        const barElement = document.querySelector(`[data-id="${p.id}"]`);
                        if (!barElement) return;
                        
                        const pSlot = parseInt(barElement.dataset.startSlot || 0);
                        
                        if (!inserted && targetSlot <= pSlot) {
                            newOrder = idx;
                            inserted = true;
                        }
                        
                        const newPOrder = inserted ? idx + 1 : idx;
                        
                        if (p.order !== newPOrder) {
                            affectedIds.push(p.id);
                            p.order = newPOrder;
                        }
                    });
                    
                    if (!inserted) {
                        newOrder = sameLineProds.length;
                    }
                    
                    prod.order = newOrder;
                    
                    pendingMove = {
                        barId: barId,
                        backup: backup,
                        affectedIds: affectedIds,
                        noST: false
                    };
                }
                
                showMoveConfirmation();
                generateGantt();
            });
        });
    }
    
    // ğŸ”¥ ë“œë˜ê·¸ ì‹œ ST ê¸°ë°˜ ìë™ê³„ì‚°
    function recalculateDurationOnDrag(prod, newLine) {
        // ëª¨ë¸ëª… ì°¾ê¸°
        let baseModelName = prod.model;
        if (prod.isMerged && prod.mergedData && prod.mergedData.length > 0) {
            baseModelName = prod.mergedData[0].model;
        }
        
        // PCB ì°¾ê¸°
        let pcbToFind = prod.pcb;
        
        // ì–‘ë©´(1/2ì°¨)ì¸ ê²½ìš°
        if (pcbToFind && (pcbToFind.includes('1') && pcbToFind.includes('2'))) {
            const lineModel1st = stData.find(item => 
                (item.modelName === baseModelName || item.nickname === baseModelName) && 
                item.line === newLine &&
                item.pcb === '1ì°¨'
            );
            
            const lineModel2nd = stData.find(item => 
                (item.modelName === baseModelName || item.nickname === baseModelName) && 
                item.line === newLine &&
                item.pcb === '2ì°¨'
            );
            
            let totalDuration = 0;
            let found = false;
            
            if (lineModel1st) {
                let duration1st = 0;
                if (lineModel1st.quantity > 0) {
                    const ratio1st = prod.quantity / lineModel1st.quantity;
                    duration1st = lineModel1st.duration * ratio1st;
                } else if (lineModel1st.stValue > 0 && lineModel1st.efficiency > 0) {
                    duration1st = prod.quantity / (60 / lineModel1st.stValue * 10 * lineModel1st.efficiency);
                }
                if (duration1st > 0) {
                    totalDuration += duration1st;
                    found = true;
                }
            }
            
            if (lineModel2nd) {
                let duration2nd = 0;
                if (lineModel2nd.quantity > 0) {
                    const ratio2nd = prod.quantity / lineModel2nd.quantity;
                    duration2nd = lineModel2nd.duration * ratio2nd;
                } else if (lineModel2nd.stValue > 0 && lineModel2nd.efficiency > 0) {
                    duration2nd = prod.quantity / (60 / lineModel2nd.stValue * 10 * lineModel2nd.efficiency);
                }
                if (duration2nd > 0) {
                    totalDuration += duration2nd;
                    found = true;
                }
            }
            
            if (found) {
                prod.duration = totalDuration;
            }
            
            return { found: found };
        }
        
        // ë‹¨ë©´ì¸ ê²½ìš°
        const lineModel = stData.find(item => 
            (item.modelName === baseModelName || item.nickname === baseModelName) && 
            item.line === newLine &&
            item.pcb === pcbToFind
        );
        
        if (!lineModel) {
            return { found: false };
        }
        
        let calculatedDuration = 0;
        
        if (lineModel.quantity > 0) {
            const ratio = prod.quantity / lineModel.quantity;
            calculatedDuration = lineModel.duration * ratio;
        } 
        else if (lineModel.stValue > 0 && lineModel.efficiency > 0) {
            calculatedDuration = prod.quantity / (60 / lineModel.stValue * 10 * lineModel.efficiency);
        } 
        else {
            return { found: false };
        }
        
        prod.duration = calculatedDuration;
        return { found: true };
    }
    
    function showMoveConfirmation() {
        if (!pendingMove) return;
        
        const prod = productionData.find(p => p.id === pendingMove.barId);
        if (!prod) return;
        
        const panel = document.getElementById('moveConfirmPanel');
        const infoDiv = document.getElementById('moveInfo');
        
        const oldData = pendingMove.backup.find(b => b.id === pendingMove.barId);
        
        // ğŸ”¥ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
        panel.classList.remove('st-warning', 'parking-move');
        
        // ğŸ”¥ ì„ì‹œ ë¼ì¸ ì´ë™
        if (pendingMove.isParking) {
            panel.classList.add('parking-move');
            infoDiv.textContent = 'ë¼ì¸ ' + oldData.line + ' â†’ ì„ì‹œ ë¼ì¸ìœ¼ë¡œ ì´ë™\nì†Œìš”ì¼: ' + oldData.duration.toFixed(1) + ' Shift â†’ 1 Shift (ë³´ê´€)';
        } 
        // ğŸ”¥ ì„ì‹œì—ì„œ ë³µì›
        else if (pendingMove.isUnparking) {
            panel.classList.add('parking-move');
            let moveText = 'ì„ì‹œ ë¼ì¸ â†’ ë¼ì¸ ' + prod.line + 'ë¡œ ë³µì›';
            if (pendingMove.noST) {
                moveText += '\nâš ï¸ ' + prod.line + 'ë¼ì¸ ST ë°ì´í„° ì—†ìŒ\n(ì›ë˜ ì†Œìš”ì¼ ' + prod.duration.toFixed(1) + ' Shift ë³µì›)';
            } else {
                moveText += '\nì†Œìš”ì¼: 1 Shift â†’ ' + prod.duration.toFixed(1) + ' Shift (ì¬ê³„ì‚°)';
            }
            infoDiv.textContent = moveText;
            
            if (pendingMove.noST) {
                panel.classList.add('st-warning');
            }
        }
        // ğŸ”¥ ST ì—†ìŒ ê²½ê³ 
        else if (pendingMove.noST) {
            panel.classList.add('st-warning');
            let moveText = 'ë¼ì¸ ' + oldData.line + ' â†’ ë¼ì¸ ' + prod.line + 'ë¡œ ì´ë™';
            moveText += '\nâš ï¸ ' + prod.line + 'ë¼ì¸ ST ë°ì´í„° ì—†ìŒ\n(í˜„ì¬ ì†Œìš”ì¼ ' + prod.duration.toFixed(1) + ' Shift ìœ ì§€)';
            infoDiv.textContent = moveText;
        }
        // ğŸ”¥ ì¼ë°˜ ì´ë™
        else if (oldData.line !== prod.line) {
            infoDiv.textContent = 'ë¼ì¸ ' + oldData.line + ' â†’ ë¼ì¸ ' + prod.line + 'ë¡œ ì´ë™';
        } 
        // ğŸ”¥ ìˆœì„œ ë³€ê²½
        else {
            const affectedCount = pendingMove.affectedIds.length;
            infoDiv.textContent = 'ë¼ì¸ ' + prod.line + ' ë‚´ ìˆœì„œ ë³€ê²½ (ì˜í–¥ë°›ì€ ëª¨ë¸: ' + affectedCount + 'ê°œ)';
        }
        
        panel.classList.add('show');
    }
    
    function confirmMove() {
        pendingMove = null;
        document.getElementById('moveConfirmPanel').classList.remove('show');
        document.getElementById('moveConfirmPanel').classList.remove('st-warning');
        document.getElementById('moveConfirmPanel').classList.remove('parking-move');
        generateGantt();
    }
    
    function cancelMove() {
        if (!pendingMove) return;
        
        pendingMove.backup.forEach(backup => {
            const prod = productionData.find(p => p.id === backup.id);
            if (prod) {
                prod.line = backup.line;
                prod.order = backup.order;
                prod.duration = backup.duration;
                if (backup.originalDuration !== undefined) {
                    prod.originalDuration = backup.originalDuration;
                } else {
                    delete prod.originalDuration;
                }
            }
        });
        
        pendingMove = null;
        document.getElementById('moveConfirmPanel').classList.remove('show');
        document.getElementById('moveConfirmPanel').classList.remove('st-warning');
        document.getElementById('moveConfirmPanel').classList.remove('parking-move');
        generateGantt();
    }
    
    function clearSelection() {
        selectedBars = [];
        const bars = document.querySelectorAll('.gantt-bar');
        bars.forEach(bar => bar.classList.remove('selected'));
    }
    
    function mergeSelected() {
        if (selectedBars.length < 2) {
            alert('âš ï¸ 2ê°œ ì´ìƒì˜ ì‘ì—…ì„ ì„ íƒí•˜ì„¸ìš”!');
            return;
        }
        
        const selectedProds = selectedBars
            .map(id => productionData.find(p => p.id === id))
            .filter(p => p);
        
        if (selectedProds.length < 2) {
            alert('âš ï¸ ì„ íƒëœ ì‘ì—…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        const firstLine = selectedProds[0].line;
        const allSameLine = selectedProds.every(p => p.line === firstLine);
        
        if (!allSameLine) {
            alert('âš ï¸ ê°™ì€ ë¼ì¸ì˜ ì‘ì—…ë§Œ ë¬¶ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!');
            return;
        }
        
        // ğŸ”¥ ì„ì‹œ ë¼ì¸ ì‘ì—…ì€ ë¬¶ì„ ìˆ˜ ì—†ìŒ
        if (firstLine === 'ì„ì‹œ') {
            alert('âš ï¸ ì„ì‹œ ë¼ì¸ì˜ ì‘ì—…ì€ ë¬¶ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        const hasMerged = selectedProds.some(p => p.isMerged);
        if (hasMerged) {
            alert('âš ï¸ ì´ë¯¸ ë¬¶ìŒëœ í•­ëª©ì€ ë‹¤ì‹œ ë¬¶ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!\në¨¼ì € ë¬¶ìŒ í•´ì œë¥¼ í•´ì£¼ì„¸ìš”.');
            clearSelection();
            return;
        }
        
        selectedProds.sort((a, b) => a.order - b.order);
        
        const originalData = selectedProds.map(p => ({
            id: p.id,
            model: p.model,
            quantity: p.quantity,
            duration: p.duration,
            pcb: p.pcb,
            memo: p.memo,
            color: p.color,
            nightOff: p.nightOff,
            line: p.line
        }));
        
        const mergedModelDisplay = selectedProds.map(p => {
            const modelName = p.model;
            const pcbStr = p.pcb ? p.pcb : '';
            return modelName + (pcbStr ? ' ' + pcbStr : '') + ' ' + p.quantity.toLocaleString() + 'ea';
        }).join(' + ');
        
        const mergedDuration = selectedProds.reduce((sum, p) => sum + p.duration, 0);
        const mergedMemo = selectedProds.map(p => p.memo).filter(m => m).join(', ');
        
        const firstProd = selectedProds[0];
        const firstOrder = firstProd.order;
        const firstColor = firstProd.color;
        
        firstProd.model = mergedModelDisplay;
        firstProd.quantityDisplay = '';
        firstProd.quantity = selectedProds[0].quantity;
        firstProd.duration = mergedDuration;
        firstProd.pcb = '';
        firstProd.memo = mergedMemo;
        firstProd.isMerged = true;
        firstProd.mergedIds = selectedBars.slice();
        firstProd.mergedData = originalData;
        firstProd.order = firstOrder;
        firstProd.color = firstColor;
        
        for (let i = 1; i < selectedProds.length; i++) {
            productionData = productionData.filter(p => p.id !== selectedProds[i].id);
        }
        
        clearSelection();
        generateGantt();
    }
    
    function unmergeProduction(id) {
        const prod = productionData.find(p => p.id === id);
        
        if (!prod || !prod.isMerged) {
            alert('âš ï¸ ë¬¶ìŒ ì‘ì—…ì´ ì•„ë‹™ë‹ˆë‹¤!');
            return;
        }
        
        if (!prod.mergedData || prod.mergedData.length === 0) {
            alert('âš ï¸ ë¬¶ìŒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!\nì´ í•­ëª©ì€ ë‹¨ì¼ ì‘ì—…ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.');
            prod.isMerged = false;
            delete prod.mergedData;
            delete prod.mergedIds;
            delete prod.quantityDisplay;
            generateGantt();
            return;
        }
        
        if (!confirm('ë¬¶ìŒì„ í•´ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        
        const currentLine = prod.line;
        const baseOrder = prod.order;
        productionData = productionData.filter(p => p.id !== id);
        
        prod.mergedData.forEach((item, idx) => {
            const newProd = {
                id: Math.floor(Date.now() + idx + Math.random() * 10000),
                line: item.line || currentLine,
                model: item.model,
                quantity: item.quantity,
                duration: item.duration,
                pcb: item.pcb,
                color: item.color,
                memo: item.memo || '',
                nightOff: item.nightOff || false,
                order: baseOrder + idx
            };
            
            productionData.push(newProd);
        });
        
        generateGantt();
    }
    
    function editProduction(id) {
        const prod = productionData.find(p => p.id === id);
        if (!prod) return;
        
        const mergedBadge = prod.isMerged ? '<span style="background: #2196F3; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 10px;">ë¬¶ìŒ</span>' : '';
        
        const formHtml = `
            <div style="font-family: 'Malgun Gothic'; padding: 10px;">
                <h3 style="margin-bottom: 15px;">ğŸ“ ìƒì‚°ê³„íš ìˆ˜ì •${mergedBadge}</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ­ ë¼ì¸:</label>
                    <select id="edit_line" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                        <option value="A" ${prod.line === 'A' ? 'selected' : ''}>A</option>
                        <option value="B" ${prod.line === 'B' ? 'selected' : ''}>B</option>
                        <option value="C" ${prod.line === 'C' ? 'selected' : ''}>C</option>
                        <option value="D" ${prod.line === 'D' ? 'selected' : ''}>D</option>
                        <option value="E" ${prod.line === 'E' ? 'selected' : ''}>E</option>
                        <option value="F" ${prod.line === 'F' ? 'selected' : ''}>F</option>
                        <option value="G" ${prod.line === 'G' ? 'selected' : ''}>G</option>
                        <option value="ì„ì‹œ" ${prod.line === 'ì„ì‹œ' ? 'selected' : ''}>ì„ì‹œ</option>
                    </select>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ“¦ ëª¨ë¸ëª…:</label>
                    <input type="text" id="edit_model" value="${prod.model}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px; ime-mode: disabled;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ“Š ìˆ˜ëŸ‰:</label>
                    <input type="number" id="edit_qty" value="${prod.quantity}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ”§ PCB êµ¬ë¶„:</label>
                    <input type="text" id="edit_pcb" value="${prod.pcb || ''}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">â±ï¸ ì†Œìš”ì¼:</label>
                    <input type="number" id="edit_dur" value="${prod.duration}" step="0.1" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ¨ ìƒ‰ìƒ:</label>
                    <select id="edit_color" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                        <option value="1" ${prod.color === '1' ? 'selected' : ''}>1-ë…¸ë‘</option>
                        <option value="2" ${prod.color === '2' ? 'selected' : ''}>2-í•‘í¬</option>
                        <option value="3" ${prod.color === '3' ? 'selected' : ''}>3-íŒŒë‘</option>
                        <option value="4" ${prod.color === '4' ? 'selected' : ''}>4-ì—°ë‘</option>
                        <option value="5" ${prod.color === '5' ? 'selected' : ''}>5-íšŒìƒ‰</option>
                        <option value="6" ${prod.color === '6' ? 'selected' : ''}>6-ë¯¸ê°€ë™</option>
                    </select>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ“ ë©”ëª¨:</label>
                    <input type="text" id="edit_memo" value="${prod.memo || ''}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="edit_nightOff" ${prod.nightOff ? 'checked' : ''}>
                        <span>ì£¼ê°„ë§Œ ì‘ì—… (ì•¼ê°„ ê±´ë„ˆë›°ê¸°)</span>
                    </label>
                </div>
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <div style="display: flex; gap: 10px;">
                        ${prod.isMerged ? '<button onclick="unmergeProduction(' + id + '); cancelEdit();" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ”“ ë¬¶ìŒí•´ì œ</button>' : ''}
                        <button onclick="deleteProductionFromEdit(' + id + ')" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ—‘ï¸ ì‚­ì œ</button>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="cancelEdit()" style="padding: 8px 16px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">ì·¨ì†Œ</button>
                        <button onclick="saveEdit(${id})" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">ì €ì¥</button>
                    </div>
                </div>
            </div>
        `;
        
        const modal = document.createElement('div');
        modal.id = 'editModal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';
        
        const modalContent = document.createElement('div');
        modalContent.style.cssText = 'background: white; padding: 20px; border-radius: 8px; max-width: 450px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
        modalContent.innerHTML = formHtml;
        
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        
        // ğŸ”¥ ìˆ˜ì • ëª¨ë‹¬ ë‚´ ìë™ê³„ì‚° ì´ë²¤íŠ¸ ì¶”ê°€
        const editLine = document.getElementById('edit_line');
        const editQty = document.getElementById('edit_qty');
        const editPcb = document.getElementById('edit_pcb');
        
        if (editLine) {
            editLine.addEventListener('change', function() {
                recalculateSTInModal(id);
            });
        }
        if (editQty) {
            editQty.addEventListener('input', function() {
                recalculateSTInModal(id);
            });
        }
        if (editPcb) {
            editPcb.addEventListener('input', function() {
                recalculateSTInModal(id);
            });
        }
    }
    
    function deleteProductionFromEdit(id) {
        if (!confirm('ì´ ì‘ì—…ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        
        productionData = productionData.filter(p => p.id !== id);
        
        cancelEdit();
        generateGantt();
    }
    
    function saveEdit(id) {
        const prod = productionData.find(p => p.id === id);
        if (!prod) return;
        
        const newLine = document.getElementById('edit_line').value;
        
        // ë¼ì¸ì´ ë³€ê²½ë˜ì—ˆê³  ê°™ì€ ë¼ì¸ì˜ ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™
        if (prod.line !== newLine) {
            const targetLineProds = productionData.filter(p => p.line === newLine && p.id !== id);
            const maxOrder = targetLineProds.length > 0 
                ? Math.max(...targetLineProds.map(p => p.order)) 
                : -1;
            
            // ğŸ”¥ ì„ì‹œ ë¼ì¸ìœ¼ë¡œ ì´ë™ ì‹œ
            if (newLine === 'ì„ì‹œ' && prod.line !== 'ì„ì‹œ') {
                if (!prod.originalDuration) {
                    prod.originalDuration = prod.duration;
                }
                prod.duration = 1;
            }
            // ğŸ”¥ ì„ì‹œì—ì„œ ì¼ë°˜ ë¼ì¸ìœ¼ë¡œ ë³µì› ì‹œ
            else if (prod.line === 'ì„ì‹œ' && newLine !== 'ì„ì‹œ') {
                if (prod.originalDuration) {
                    prod.duration = prod.originalDuration;
                    delete prod.originalDuration;
                }
            }
            
            prod.line = newLine;
            prod.order = maxOrder + 1;
        }
        
        prod.model = document.getElementById('edit_model').value;
        prod.quantity = parseInt(document.getElementById('edit_qty').value);
        prod.duration = parseFloat(document.getElementById('edit_dur').value);
        
        let pcbValue = document.getElementById('edit_pcb').value.trim();
        if (pcbValue === '1') {
            pcbValue = '1ì°¨';
        } else if (pcbValue === '2') {
            pcbValue = '2ì°¨';
        } else if (pcbValue === '12' || pcbValue === '1/2') {
            pcbValue = '1/2ì°¨';
        }
        prod.pcb = pcbValue;
        
        prod.color = document.getElementById('edit_color').value;
        prod.memo = document.getElementById('edit_memo').value;
        prod.nightOff = document.getElementById('edit_nightOff').checked;
        
        if (!prod.isMerged) {
            delete prod.quantityDisplay;
        }
        
        cancelEdit();
        generateGantt();
    }
    
    function cancelEdit() {
        const modal = document.getElementById('editModal');
        if (modal) modal.remove();
    }
    
    function zoomIn() {
        if (zoomLevel >= 200) return;
        zoomLevel += 10;
        applyZoom();
    }
    
    function zoomOut() {
        if (zoomLevel <= 50) return;
        zoomLevel -= 10;
        applyZoom();
    }
    
    function applyZoom() {
        const chart = document.getElementById('ganttChart');
        chart.style.transform = 'scale(' + (zoomLevel / 100) + ')';
        document.getElementById('zoomLevel').textContent = zoomLevel;
    }
    
    function exportCSV() {
        if (productionData.length === 0) {
            alert('âš ï¸ ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        // ğŸ”¥ ì„ì‹œ ë¼ì¸ í¬í•¨ ëª¨ë“  ë¼ì¸ ì •ë ¬
        const lines = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'ì„ì‹œ'];
        lines.forEach(line => {
            const lineProds = productionData
                .filter(p => p.line === line)
                .sort((a, b) => a.order - b.order);
            
            lineProds.forEach((prod, idx) => {
                prod.order = idx;
            });
        });
        
        let csv = 'ë¼ì¸,ëª¨ë¸ëª…,ìˆ˜ëŸ‰,ì†Œìš”ì¼,PCB,ìƒ‰ìƒ,ì£¼ê°„ì „ìš©,ë©”ëª¨,ìˆœì„œ,ë¬¶ìŒì—¬ë¶€,ë¬¶ìŒë°ì´í„°,ìˆ˜ëŸ‰í‘œì‹œ,ê³µì§€ì‚¬í•­,ì›ë˜ì†Œìš”ì¼\n';
        productionData.forEach((item, idx) => {
            const mergedDataStr = item.isMerged && item.mergedData ? 
                JSON.stringify(item.mergedData).replace(/"/g, '""') : '';
            
            const noticeField = idx === 0 ? '"' + (noticeContent || '').replace(/"/g, '""') + '"' : '';
            
            // ğŸ”¥ originalDuration ì €ì¥
            const originalDurationField = item.originalDuration ? item.originalDuration : '';
            
            csv += item.line + ',' +
                '"' + item.model.replace(/"/g, '""') + '",' +
                item.quantity + ',' +
                item.duration + ',' +
                (item.pcb || '') + ',' +
                item.color + ',' +
                (item.nightOff ? 'X' : '') + ',' +
                '"' + (item.memo || '').replace(/"/g, '""') + '",' +
                item.order + ',' +
                (item.isMerged ? 'Y' : '') + ',' +
                '"' + mergedDataStr + '",' +
                '"' + (item.quantityDisplay || '').replace(/"/g, '""') + '",' +
                noticeField + ',' +
                originalDurationField + '\n';
        });
        
        const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'ìƒì‚°ê³„íš_' + new Date().toISOString().slice(0,10) + '.csv';
        link.click();
    }
    
    function loadCSV() {
        document.getElementById('csvLoadFile').click();
    }
    
    function importCSV(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const fileName = file.name;
        const dateMatch = fileName.match(/(\d{4}-\d{2}-\d{2})/);
        if (dateMatch) {
            const extractedDate = dateMatch[1];
            document.getElementById('startDate').value = extractedDate;
            originalCsvDate = extractedDate;
            console.log('âœ… ì›ë³¸ CSV ë‚ ì§œ:', extractedDate);
        } else {
            originalCsvDate = null;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const lines = text.split('\n');
            
            productionData = [];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const cells = parseCSVLine(line);
                
                if (cells.length < 9) continue;
                
                if (i === 1 && cells.length >= 13 && cells[12]) {
                    noticeContent = cells[12];
                    document.getElementById('noticeText').value = noticeContent;
                }
                
                const isMerged = cells[9] === 'Y';
                let mergedData = null;
                
                if (isMerged && cells[10] && cells[10].trim()) {
                    try {
                        mergedData = JSON.parse(cells[10]);
                        console.log('âœ… ë¬¶ìŒ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ:', mergedData);
                    } catch (e) {
                        console.error('âŒ ë¬¶ìŒ ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨:', e.message);
                        console.error('ğŸ“„ ì›ë³¸ ë°ì´í„°:', cells[10]);
                    }
                }
                
                const newProd = {
                    id: Math.floor(Date.now() + i + Math.random() * 10000),
                    line: cells[0],
                    model: cells[1].replace(/<br>/gi, ' ').trim(),
                    quantity: parseInt(cells[2]) || 0,
                    duration: parseFloat(cells[3]) || 0,
                    pcb: cells[4],
                    color: cells[5],
                    nightOff: cells[6] === 'X',
                    memo: cells[7],
                    order: parseInt(cells[8]) || 0
                };
                
                if (isMerged) {
                    newProd.isMerged = true;
                    newProd.quantityDisplay = '';
                    
                    if (mergedData && Array.isArray(mergedData) && mergedData.length > 0) {
                        newProd.mergedData = mergedData;
                        newProd.mergedIds = mergedData.map(d => d.id);
                    }
                }
                
                // ğŸ”¥ originalDuration ë¶ˆëŸ¬ì˜¤ê¸°
                if (cells.length >= 14 && cells[13]) {
                    const origDur = parseFloat(cells[13]);
                    if (!isNaN(origDur) && origDur > 0) {
                        newProd.originalDuration = origDur;
                    }
                }
                
                productionData.push(newProd);
            }
            
            const dateInfo = dateMatch ? ' (ì‹œì‘ë‚ ì§œ: ' + dateMatch[1] + ')' : '';
            alert('âœ… CSV ë°ì´í„° ' + productionData.length + 'ê°œ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!' + dateInfo);
            console.log('ë¶ˆëŸ¬ì˜¨ ë°ì´í„°:', productionData);
            generateGantt();
        };
        reader.readAsText(file, 'UTF-8');
        
        const originalOnload = reader.onload;
        reader.onload = function(e) {
            const text = e.target.result;
            if (text.includes(' ') || text.includes('\ufffd')) {
                console.log('âš ï¸ CSV UTF-8 ì¸ì½”ë”© ì‹¤íŒ¨, EUC-KR ì‹œë„...');
                const reader2 = new FileReader();
                reader2.onload = originalOnload;
                reader2.readAsText(file, 'EUC-KR');
            } else {
                originalOnload(e);
            }
        };
    }
    
    function cleanupPastWork() {
        if (!originalCsvDate) {
            alert('âš ï¸ ì›ë³¸ CSV ë‚ ì§œ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤!\nCSV íŒŒì¼ì„ ë¨¼ì € ë¶ˆëŸ¬ì™€ì£¼ì„¸ìš”.');
            return;
        }
        
        if (productionData.length === 0) {
            alert('âš ï¸ ì •ë¦¬í•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        const currentStartDate = document.getElementById('startDate').value;
        if (!currentStartDate) {
            alert('âš ï¸ ì‹œì‘ë‚ ì§œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
            return;
        }
        
        parseHolidays();
        
        const originalDate = new Date(originalCsvDate);
        const newStartDate = new Date(currentStartDate);
        const diffTime = newStartDate - originalDate;
        const totalDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
        
        if (totalDays <= 0) {
            alert('âš ï¸ ì‹œì‘ë‚ ì§œê°€ ì›ë³¸ ë‚ ì§œë³´ë‹¤ ì´ì „ì´ê±°ë‚˜ ê°™ìŠµë‹ˆë‹¤!\nì •ë¦¬í•  ê³¼ê±° ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        let workDays = 0;
        const dateDetails = [];
        
        for (let i = 0; i < totalDays; i++) {
            const checkDate = new Date(originalDate);
            checkDate.setDate(checkDate.getDate() + i);
            const dateStr = checkDate.toISOString().split('T')[0];
            const dayOfWeek = checkDate.getDay();
            const dayName = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '][dayOfWeek];
            
            let isWorkDay = true;
            let reason = 'ì‘ì—…ì¼';
            
            if (holidays[dateStr] === 'íœ´ë¬´') {
                isWorkDay = false;
                reason = 'íœ´ë¬´';
            } 
            else if (holidays[dateStr] === 'íŠ¹ê·¼') {
                isWorkDay = true;
                reason = 'íŠ¹ê·¼';
            }
            else if (dayOfWeek === 0 || dayOfWeek === 6) {
                isWorkDay = false;
                reason = 'ì£¼ë§';
            }
            
            if (isWorkDay) {
                workDays++;
            }
            
            dateDetails.push({
                date: `${checkDate.getMonth()+1}/${checkDate.getDate()}(${dayName})`,
                reason: reason,
                isWorkDay: isWorkDay
            });
        }
        
        console.log('ğŸ” ë‚ ì§œ ë¶„ì„:', {
            ì›ë³¸ë‚ ì§œ: originalCsvDate,
            í˜„ì¬ë‚ ì§œ: currentStartDate,
            ì´ì¼ìˆ˜: totalDays,
            ì‹¤ì œì‘ì—…ì¼ìˆ˜: workDays
        });
        
        dateDetails.forEach(d => {
            console.log(`  ${d.date}: ${d.reason} ${d.isWorkDay ? 'âœ…' : 'âŒ'}`);
        });
        
        if (workDays <= 0) {
            alert('âš ï¸ ì‹¤ì œ ì‘ì—…ì¼ì´ ì—†ìŠµë‹ˆë‹¤!\n(ëª¨ë‘ ì£¼ë§ì´ê±°ë‚˜ íœ´ë¬´ì…ë‹ˆë‹¤)');
            return;
        }
        
        let dateDetailStr = '\n\nğŸ“… ë‚ ì§œ ìƒì„¸:\n';
        dateDetails.forEach(d => {
            dateDetailStr += `${d.date}: ${d.reason}\n`;
        });
        
        const confirmMsg = `ğŸ“… ì›ë³¸ ë‚ ì§œ: ${originalCsvDate}\nğŸ“… í˜„ì¬ ë‚ ì§œ: ${currentStartDate}\nâ³ ì´ ì¼ìˆ˜: ${totalDays}ì¼\nâœ… ì‹¤ì œ ì‘ì—…ì¼: ${workDays}ì¼${dateDetailStr}\n${workDays}ì¼ì¹˜ ì‘ì—…ì„ ìˆœì„œëŒ€ë¡œ ì •ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nâ€» ê° ë¼ì¸ë³„ë¡œ ì• ì‘ì—…ë¶€í„° ì°¨ê°ë©ë‹ˆë‹¤\n- ì£¼ì•¼ ì‘ì—…: 1ì¼ë‹¹ 2 Shift ì°¨ê°\n- ì£¼ê°„ë§Œ ì‘ì—…: 1ì¼ë‹¹ 1 Shift ì°¨ê°\n- ì„ì‹œ ë¼ì¸ì€ ì œì™¸`;
        
        if (!confirm(confirmMsg)) {
            return;
        }
        
        console.log('\nğŸ“Š ì°¨ê° ì „ ì‘ì—… í˜„í™©:');
        productionData.forEach(prod => {
            console.log(`${prod.line}ë¼ì¸(${prod.order}): ${prod.model} - ${prod.duration} Shift (ì£¼ê°„ì „ìš©: ${prod.nightOff ? 'O' : 'X'})`);
        });
        
        let deletedCount = 0;
        let updatedCount = 0;
        
        const lines = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; // ğŸ”¥ ì„ì‹œ ë¼ì¸ ì œì™¸
        const newProductionData = [];
        
        lines.forEach(line => {
            const lineProds = productionData
                .filter(p => p.line === line)
                .sort((a, b) => a.order - b.order);
            
            if (lineProds.length === 0) return;
            
            const isNightOff = lineProds[0].nightOff;
            let remainingDeduct = isNightOff ? workDays : (workDays * 2);
            
            console.log(`\nğŸ”¹ ${line}ë¼ì¸ ì²˜ë¦¬ ì‹œì‘ (ì°¨ê°ëŸ‰: ${remainingDeduct} Shift, ì£¼ê°„ì „ìš©: ${isNightOff ? 'O' : 'X'})`);
            
            lineProds.forEach(prod => {
                if (remainingDeduct <= 0) {
                    console.log(`âœ… ìœ ì§€: ${prod.model} - ${prod.duration} Shift (ì°¨ê°ëŸ‰ ì†Œì§„)`);
                    newProductionData.push(prod);
                    updatedCount++;
                } else {
                    const newDuration = prod.duration - remainingDeduct;
                    
                    if (newDuration <= 0) {
                        console.log(`âŒ ì‚­ì œ: ${prod.model} (${prod.duration} - ${remainingDeduct} = ${newDuration})`);
                        remainingDeduct = Math.abs(newDuration);
                        deletedCount++;
                    } else {
                        console.log(`âœ… ì°¨ê°: ${prod.model} (${prod.duration} â†’ ${newDuration.toFixed(1)} Shift)`);
                        prod.duration = newDuration;
                        newProductionData.push(prod);
                        remainingDeduct = 0;
                        updatedCount++;
                    }
                }
            });
        });
        
        // ğŸ”¥ ì„ì‹œ ë¼ì¸ ì‘ì—…ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
        const parkingProds = productionData.filter(p => p.line === 'ì„ì‹œ');
        parkingProds.forEach(prod => {
            newProductionData.push(prod);
        });
        
        productionData = newProductionData;
        
        console.log('\nğŸ“Š ì •ë¦¬ ê²°ê³¼:', {
            ì°¨ê°ëœì‘ì—…: updatedCount,
            ì‚­ì œëœì‘ì—…: deletedCount,
            ë‚¨ì€ì‘ì—…: productionData.length
        });
        
        originalCsvDate = currentStartDate;
        
        generateGantt();
        
        alert(`âœ… ê³¼ê±° ì‘ì—… ì •ë¦¬ ì™„ë£Œ!\n\nğŸ“Š ì´ ${totalDays}ì¼ ì¤‘ ì‹¤ì œ ì‘ì—…ì¼ ${workDays}ì¼ ì°¨ê°\nğŸ“Š ì°¨ê°/ìœ ì§€ëœ ì‘ì—…: ${updatedCount}ê°œ\nğŸ—‘ï¸ ì‚­ì œëœ ì‘ì—…: ${deletedCount}ê°œ\nğŸ“¦ ì„ì‹œ ì‘ì—…: ${parkingProds.length}ê°œ ìœ ì§€\n\nì´ì œ CSVë¥¼ ì €ì¥í•˜ì„¸ìš”!`);
    }
    
    function toggleMemo() {
        const ganttChart = document.getElementById('ganttChart');
        const btn = document.getElementById('memoToggleBtn');
        
        if (ganttChart.classList.contains('memo-hidden')) {
            ganttChart.classList.remove('memo-hidden');
            btn.textContent = 'ğŸ‘ï¸ ë©”ëª¨ ìˆ¨ê¹€';
            btn.style.background = 'white';
            btn.style.color = '#667eea';
        } else {
            ganttChart.classList.add('memo-hidden');
            btn.textContent = 'ğŸ‘ï¸â€ğŸ—¨ï¸ ë©”ëª¨ í‘œì‹œ';
            btn.style.background = '#4CAF50';
            btn.style.color = 'white';
        }
    }
</script>
</body>
</html>